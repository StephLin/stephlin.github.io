const V=Object.entries,et=Object.fromEntries,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>{const n=Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},bt=et(V(JSON.parse("{\"/\":{\"documentCount\":40,\"nextId\":40,\"documentIds\":{\"0\":\"1\",\"1\":\"2\",\"2\":\"3\",\"3\":\"4\",\"4\":\"5\",\"5\":\"6\",\"6\":\"6#實作案例\",\"7\":\"6#舉一個更實際的案例\",\"8\":\"6#型態檢查\",\"9\":\"7\",\"10\":\"7#background-knowledge-of-sum-of-squares-polynomials\",\"11\":\"7#semidefinite-programming-by-python\",\"12\":\"7#conclusion\",\"13\":\"7#references\",\"14\":\"8\",\"15\":\"8#單一檔案存取\",\"16\":\"8#使用-contextlib\",\"17\":\"8#case-study-1-包裝函數\",\"18\":\"8#case-study-2-轉導-stdout-到檔案流\",\"19\":\"8#case-study-3-複數資源管理-exitstack\",\"20\":\"8#資源管理的深層應用\",\"21\":\"8#結論\",\"22\":\"8#references\",\"23\":\"9\",\"24\":\"9#python-為什麼那麼慢\",\"25\":\"9#python-是動態型別語言\",\"26\":\"9#python-是直譯型語言\",\"27\":\"9#python-有全域直譯器鎖\",\"28\":\"9#加速符文\",\"29\":\"9#基礎加速符文-靜態型別\",\"30\":\"9#中級加速符文-平行處理\",\"31\":\"9#高級加速符文-再見了-python\",\"32\":\"9#心得\",\"33\":\"9#references\",\"34\":\"10\",\"35\":\"11\",\"36\":\"12\",\"37\":\"13\",\"38\":\"14\",\"39\":\"15\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[2],\"1\":[2,144],\"2\":[3,130],\"3\":[2,160],\"4\":[5,272],\"5\":[3,93],\"6\":[1,150],\"7\":[1,111],\"8\":[1,207],\"9\":[8,17],\"10\":[6,44],\"11\":[4,342],\"12\":[1,56],\"13\":[1,7],\"14\":[4,21],\"15\":[1,176],\"16\":[2,75],\"17\":[4,21],\"18\":[6,45],\"19\":[5,26],\"20\":[1,25],\"21\":[1,13],\"22\":[1,14],\"23\":[3,18],\"24\":[3,29],\"25\":[1,46],\"26\":[2,48],\"27\":[2,55],\"28\":[1,64],\"29\":[2,126],\"30\":[2,171],\"31\":[1,217],\"32\":[1,74],\"33\":[1,41],\"34\":[1,3],\"35\":[1],\"36\":[1],\"37\":[1],\"38\":[1],\"39\":[1]},\"averageFieldLength\":[2.25,86.88571428571429],\"storedFields\":{\"0\":{\"h\":\"About Me\"},\"1\":{\"h\":\"2022 - KCP\",\"t\":[\"Yu-Kai Lin, Wen-Chieh Lin, Chieh-Chih Wang, K-Closest Points and Maximum Clique Pruning for Efficient and Effective 3-D Laser Scan Matching. IEEE Robotics and Automation Letters (RA-L), vol.7, no. 2, pp. 1471 -- 1477, Apr. 2022.\",\"We propose K-Closest Points (KCP), an efficient and effective laser scan matching approach inspired by LOAM and TEASER++. The efficiency of KCP comes from a feature point extraction approach utilizing the multi-scale curvature and a heuristic matching method based on the k-closest points. The effectiveness of KCP comes from the integration of the feature point matching approach and the maximum clique pruning. We compare KCP against well-known scan matching approaches on synthetic and real-world LiDAR data (nuScenes dataset). In the synthetic data experiment, KCP-TEASER reaches a state-of-the-art root-mean-square transformation error (0.006m, 0.014deg) with average computational time 49ms. In the real-world data experiment, KCP-TEASER achieves an average error of (0.018m, 0.101deg) with average computational time 77ms. This shows its efficiency and effectiveness in real-world scenarios. Through theoretic derivation and empirical experiments, we also reveal the outlier correspondence penetration issue of the maximum clique pruning that it may still contain outlier correspondences.\",\"For more details, please refer to the following links:\"]},\"2\":{\"h\":\"2023 - LIO-SEGMOT\",\"t\":[\"Yu-Kai Lin, Wen-Chieh Lin, Chieh-Chih Wang, Asynchronous State Estimation of Simultaneous Ego-motion Estimation and Multiple Object Tracking for LiDAR-Inertial Odometry. 2023 International Conference on Robotics and Automation (ICRA), pp. 10616--10622, May 2023.\",\"We propose LiDAR-Inertial Odometry via Simultaneous EGo-motion estimation and Multiple Object Tracking (LIO-SEGMOT), an optimization-based odometry approach targeted for dynamic environments. LIO-SEGMOT is formulated as a state estimation approach with asynchronous state update of the odometry and the object tracking. That is, LIO-SEGMOT can provide continuous object tracking results while preserving the keyframe selection mechanism in the odometry system. Meanwhile, a hierarchical criterion is designed to properly couple odometry and object tracking, preventing system instability due to poor detections. We compare LIO-SEGMOT against the baseline model LIO-SAM, a state-of-the-art LIO approach, under dynamic environments of the KITTI raw dataset and the self-collected Hsinchu dataset. The former experiment shows that LIO-SEGMOT obtains an average improvement 1.61% and 5.41% of odometry accuracy in terms of absolute translational and rotational trajectory errors. The latter experiment also indicates that LIO-SEGMOT obtains an average improvement 6.97% and 4.21% of odometry accuracy.\",\"For more information, please refer to the following links:\"]},\"3\":{\"h\":\"2024 - FracGM\",\"t\":[\"Bang-Shien Chen, Yu-Kai Lin, Jian-Yu Chen, Chih-Wei Huang, Jann-Long Chern, Ching-Cherng Sun, FracGM: A Fast Fractional Programming Technique for Geman-McClure Robust Estimator. IEEE Robotics and Automation Letters (RA-L), 2024.\",\"Robust estimation is essential in computer vision, robotics, and navigation, aiming to minimize the impact of outlier measurements for improved accuracy. We present a fast algorithm for Geman-McClure robust estimation, FracGM, leveraging fractional programming techniques. This solver reformulates the original non-convex fractional problem to a convex dual problem and a linear equation system, iteratively solving them in an alternating optimization pattern. Compared to graduated non-convexity approaches, this strategy exhibits a faster convergence rate and better outlier rejection capability. In addition, the global optimality of the proposed solver can be guaranteed under given conditions. We demonstrate the proposed FracGM solver with Wahba's rotation problem and 3-D point-cloud registration along with relaxation pre-processing and projection post-processing. Compared to state-of-the-art algorithms, when the outlier rates increase from 20% to 80%, FracGM shows 53% and 88% lower rotation and translation increases. In real-world scenarios, FracGM achieves better results in 13 out of 18 outcomes, while having a 19.43% improvement in the computation time.\",\"For more details, please refer to the following links:\"]},\"4\":{\"h\":\"2024 - AI-Enhanced GNSS/INS\",\"t\":[\"An-Lin Tao, Yu-Kai Lin, Hau-Hsiang Chan, Li-Min Lin, Pei-Shan Kao, AI-Enhanced Smartphone-Based GNSS/INS Integration: Improved Vehicular/Pedestrian Navigation in Challenging Scenarios Using Machine Learning. ION GNSS+ 2024 (Session C4: Positioning Technologies and Machine Learning), Sep. 2024.\",\"The utilization of mobile phone positioning for navigation has become a fundamental aspect of modern life. However, enabling mobile phones to provide positioning in urban areas presents greater challenges due to the need to minimize hardware size and costs, in contrast to traditional GNSS receivers. The effective integration of inertial navigation units (IMU) and GNSS has emerged as a critical issue.\",\"MediaTek, as a provider of a wide range of mobile products, has collected data on challenging scenarios worldwide through customer feedback. Leveraging a substantial volume of data, the appropriate integration of artificial intelligence (AI) and the utilization of machine learning (ML) technology have the potential to enhance positioning accuracy across diverse scenarios. Several years ago, MediaTek integrated various machine learning techniques to fuse GNSS with multiple IMU sensors. However, integrating GNSS with IMU across different usage scenarios presents four primary challenges:\",\"Requiring sensor calibration.\",\"Determining the relationship between the user's mobile phone and the carrier (such as a vehicle or pedestrian, etc.).\",\"Classifying the accuracy of GNSS observations in challenging environments.\",\"Adjusting the parameters of GNSS and IMU through EKF in different scenarios.\",\"This paper will provide a method to use machine learning in real-time to solve the above-mentioned problems with limited platform computing capacity. The specific contributions are delineated as follows:\",\"Static identification using machine learning: Overcoming disparities among various usage scenarios and diverse sensors to furnish users with consistent positioning results while simultaneously conducting sensor calibration.\",\"State identification using machine learning: Identifying whether the user is driving, walking, or running, and integrating distinct algorithms to optimize sensor integration with GNSS based on varying usage states.\",\"Observation filtering using machine learning: Training on a comprehensive dataset to predict accurate GNSS observation quality, selecting high-quality observations, excluding abnormal ones, and furnishing accuracy indicators integrated with sensors.\",\"Adjusting key parameters of the integrated system using machine learning: Automatically optimizing the numerous parameters of sensors and GNSS within a tightly-coupled Kalman filter, rapidly achieving equilibrium upon the introduction of new sensors or GNSS signals.\",\"Ultimately, this paper will present the performance disparities before and after applying the proposed method:\",\"The average accuracy of static detection can be increased by 23%.\",\"For high-vibration scenes, the improvement can reach up to 87%;\",\"The accuracy of state recognition can achieve 98%;\",\"The accuracy of GNSS observation selection can be boosted by 30%.\",\"Finally, the user positioning accuracy is enhanced by 10%.\",\"By leveraging the techniques expounded in this paper, MediaTek's products can furnish mobile phone users with more precise navigation services across various environments.\",\"For more information, please refer to the following link:\"]},\"5\":{\"h\":\"C++ Traits 不專業使用心得\",\"t\":[\"近期在閱讀一些 C++ Library 的過程中發現了 C++ Traits 的使用概念，於是乎來整理一下他的想法以及實現方法。\",\"Traits 簡單來講就是一個程式碼片段，而我們希望透過一些機制，把他當作補丁一般地，貼到某塊程式碼內。\",\"這個概念若使用得當，最大的好處在於我們不用重複實作相同的功能 (或是相似的架構)，進而提升程式碼的重複利用度、以及簡潔程度。\",\"Think of a trait as a small object whose main purpose is to carry information used by another object or algorithm to determine \\\"policy\\\" or \\\"implementation details\\\". --- \",\"我們先看最簡單的案例，PHP，他有一個關鍵字就直接叫做 trait，只要在其中定義想要打包的程式碼，就可以再利用 use 貼到任何類別：\",\"<?php trait ezcReflectionReturnInfo { function getReturnType() { /*1*/ } function getReturnDescription() { /*2*/ } } class ezcReflectionMethod extends ReflectionMethod { use ezcReflectionReturnInfo; /* ... */ } class ezcReflectionFunction extends ReflectionFunction { use ezcReflectionReturnInfo; /* ... */ } ?>\",\"在這個例子當中，ezcReflectionMethod 和 ezcReflectionFunction 都同時擁有 getReturnType() 和 getReturnDescription() 這兩個方法，就這方面來講 PHP 真的是滿直觀的，不過你會發現他就真的只是複製貼上而已。\",\"Tips\",\"Trait 跟 inheritance (繼承) 最大的差異是：trait 更接近於文本的複製貼上 (只是這個過程是編譯器幫你完成的)，而繼承則是一個物件導向的概念，具備更多類別之間的相互關係。\",\"如果是 C++ 的話，我們稱之為 trait class，他依靠了 C++ template (generic programming) 去實現這個想法，而仰賴模板偏特化 (partial template specialization) 的特性，我們可以進一步允許當使用者輸入不同的類別時，他會貼上個別對應的實作方法。\"]},\"6\":{\"h\":\"實作案例\",\"t\":[\"先來看一個例子：\",\"#include <iostream> // generic type template<typename T> struct traits { static bool is_void() { return false; } }; // partial template specialization template<> struct traits<void> { static bool is_void() { return true; } }; int main() { std::cout << (traits<int>::is_void() ? \\\"True\\\" : \\\"False\\\") << '\\\\n'; std::cout << (traits<float>::is_void() ? \\\"True\\\" : \\\"False\\\") << '\\\\n'; std::cout << (traits<void>::is_void() ? \\\"True\\\" : \\\"False\\\") << '\\\\n'; return 0; }\",\"在這個例子中，我們使用了 template struct 宣告並定義在一般情況 (非 void 的其他所有型態) 與特定情況 (void 型態) 在 is_void() 函數中的行為，並且很簡易地在主函數中直接呼叫。\",\"Tips\",\"在 C++ 當中， struct 跟 class 基本上是在講同樣的東西 (從編譯器的角度也是)，差異是 struct 中的成員預設為 public，而 class 中的成員預設為 private.\",\"你可能不知道的是，C++ 的 struct 跟 C 的 struct 反而不是同樣的東西。\",\"這個例子的輸出結果是滿直覺的：\",\"False False True\",\"我們可以進一步將主函數當中的行為包裝成一個 template function：\",\"#include <iostream> // generic type template<typename T> struct traits { static bool is_void() { return false; } }; // partial template specialization template<> struct traits<void> { static bool is_void() { return true; } }; template<typename T> void print_type_is_void() { std::cout << (traits<T>::is_void() ? \\\"True\\\" : \\\"False\\\") << '\\\\n'; } int main() { print_type_is_void<int>(); print_type_is_void<float>(); print_type_is_void<void>(); return 0; }\",\"在這個例子裡，我們已經可以看到 print_type_is_void<T>() 會根據他接收到的型態 T 去決定要實際向誰取得實作內容。按照這個例子的話，如果 T 是 void ，他會把含有 return true; 的那個函數拿來使用，其他的則是會把含有 return false; 的另外一個來使用。\",\"我們再把 C++ template 玩深一點，實際上更多的使用情境是：不見得每個型態都有相同的行為，而在抽象層面上我們也不是很介意各自實作細節。因此我們只要有 trait 那個皮就好，裡面的餡料我們晚點再一個個型態各自定義：\",\"#include <iostream> // declaration template<typename T> struct traits; template<> struct traits<int> { static bool is_void() { return false; } }; template<> struct traits<float> { static bool is_void() { return false; } }; template<> struct traits<void> { static bool is_void() { return true; } }; template<typename T> void print_type_is_void() { std::cout << (traits<T>::is_void() ? \\\"True\\\" : \\\"False\\\") << '\\\\n'; } int main() { print_type_is_void<int>(); print_type_is_void<float>(); print_type_is_void<void>(); return 0; }\",\"這個時候 struct traits<T> 就只剩下宣告而已，至於 print_type_is_void<T>() 其實只要知道有 struct traits<T> 的存在就可以寫程式了。意思是說，你只需要在 print_type_is_void<T>() 要抓 T=int, T=float, T=void 的實際行為時，你再告訴他定義就好了，程式碼不見得需要寫在一起。\",\"抓住這個想法，我們把程式碼拆解成三個檔案：\",\"// lib.h #pragma once #include <iostream> // forward declaration template<typename T> struct traits; template<typename T> void print_type_is_void() { std::cout << (traits<T>::is_void() ? \\\"True\\\" : \\\"False\\\") << '\\\\n'; }\",\" // impl.h #pragma once // declaration template<typename T> struct traits; template<> struct traits<int> { static bool is_void() { return false; } }; template<> struct traits<float> { static bool is_void() { return false; } }; template<> struct traits<void> { static bool is_void() { return true; } };\",\"// t.cpp #include \\\"lib.h\\\" #include \\\"impl.h\\\" int main() { print_type_is_void<int>(); print_type_is_void<float>(); print_type_is_void<void>(); return 0; }\",\"其中在 lib.h 我們使用了 forward declaration，不過想得單純一點，其實就是我把 #include \\\"impl.h\\\" 替換成 template<typename T> struct traits; 這樣。\",\"Tips\",\"Forward declaration 的最大幫助在於可以降低程式碼之間的耦合程度，縮短編譯時間 (我不需要改一個小區塊，就把全部的程式碼都重新編譯)。\",\"他的合法使用時機在於編譯器是否需要知道他的實際結構 (記憶體、函數等)。在不需要知道實際結構，而只取其指標來用的前提下，我們才能透過 forward declaration 將編譯行為拆解成數個子區塊。嚴格來講，上述我們的例子並沒有做到這件事情，所以他們還是需要一起編譯。\",\"此時我們已經可以稍微感受到「黏貼」的味道：在 t.cpp 當中，我們把 impl.h 裡面的實作細節，貼到 lib.h 裡面的函數當中。這個基本上就是 C++ Trait 的主要想法，不過實際操作上更多的是活用 C++ Template 的特性。\",\"Note\",\"以至於這篇文章用某種角度來看就是 C++ template 複習篇 XD\"]},\"7\":{\"h\":\"舉一個更實際的案例\",\"t\":[\"筆者當初是在閱讀 GTSAM 時認識到這個用法，在這份實作當中他們的應用情境是在不同李群當中 Lie group 與 Lie algebra 之間的映射關係 ( 和 )，不同的李群包含旋轉群 (special orthogonal group, rotation group) 或特殊歐基里德群 (special Euclidean group) ，他們對應的函數 和 不盡相同，但也是存在一些李群內泛用的公式，比如說李群對應到微分流形 (differentiable manifold) 之微積分行為這類的，在這種情境底下套用 trait 的概念就還滿方便的。\",\"不過這個案例有點太超過了 (數學方面的那種)，我們舉一個比較通俗的案例：單變數微分的連鎖律 (chain rule)。\",\"避免可能有讀者不太清楚微積分，快速複習一下單變數的連鎖律：給定兩個函數 ，滿足以下定律：\",\"其中那個 代表的是對 微分的意思。\",\"為求簡便，我們預計來實作兩個簡單的函數，一個是二次多項式函數 ，另一個是指數函數 . 所以我們有 和 . 有這些先備知識後我們就可以來實作了：\",\"// lib.h #pragma once template<typename T> struct traits; template<typename F, typename G> double derivative_of(double x) { return traits<F>::derivative_of( traits<G>::of(x) ) * traits<G>::derivative_of(x); }\",\"// impl.h #pragma once #include <cmath> template<typename T> struct traits; class Square {}; class Exp {}; template<> struct traits<Square> { static double of(double x) { return x * x; } static double derivative_of(double x) { return 2 * x; } }; template<> struct traits<Exp> { static double of(double x) { return exp(x); } static double derivative_of(double x) { return of(x); } };\",\"// t.cpp #include <iostream> #include \\\"lib.h\\\" #include \\\"impl.h\\\" int main() { // Square ( Exp (x) ) std::cout << \\\"derivative of exp(x)^2 at x=0: \\\" << derivative_of<Square, Exp>(0) << '\\\\n'; // Exp ( Square (x) ) std::cout << \\\"derivative of exp(x^2) at x=0: \\\" << derivative_of<Exp, Square>(0) << '\\\\n'; return 0; }\",\"在這個實作方式下，兩個類別 Square 和 Exp 會變成是空的類別，內部並沒有任何函數。輸出如下：\",\"derivative of exp(x)^2 at x=0: 2 derivative of exp(x^2) at x=0: 0\",\"讀者可以快速驗算一下，應該是正確的。\",\"Note\",\"筆者在這邊澄清一點是：並不是只有一個實作方法可以實現上述案例，比如說你可以把 of() 和 derivative_of() 直接定義在 Square 跟 Exp 裡面，不過當你基於某些理由，不希望破壞類別內部方法結構時，trait 會變成是一個還不錯的選擇。\"]},\"8\":{\"h\":\"型態檢查\",\"t\":[\"接著我們進一步探討：如何限制型態結構？\",\"C++11 引進了 type traits 的概念，提供了一些關於型態的檢查工具。從傳統物件導向的角度來說，我們可以透過多型去選擇參數的可輸入型態，然而這邊「傳統」的意思是說，正常的物件導向裡面並沒有模板的概念。\",\"不過 type traits 幫了我們一把，使得我們可以實踐這個想法，例子如下：\",\"// base.h #pragma once class Function {};\",\"// lib.h #pragma once #include <type_traits> #include \\\"base.h\\\" template<typename T> struct traits; template<typename F, typename G> double derivative_of(double x) { static_assert(std::is_base_of<Function, F>::value, \\\"F should be a Function\\\"); static_assert(std::is_base_of<Function, G>::value, \\\"G should be a Function\\\"); return traits<F>::derivative_of( traits<G>::of(x) ) * traits<G>::derivative_of(x); }\",\"其中 std::is_base_of<OO, XX> 是 type_traits 標頭裡面提供的 structure，他會告訴我們 XX 是否繼承 OO，而檢查的結果會回饋在 ::value 上。以我們的例子來說，這邊又定義了一個基底類別 Function 讓其他型態繼承，而我們希望輸入進來的型態 F 跟 G 有繼承 Function.\",\"接著另一個重點是 static_assert，以前我們熟知的是 assert，他的行為是在執行期間 (runtime) 動態的檢查，而 static_assert 的關鍵特性是他會在編譯期間 (compile-time) 做檢查，這個特性使得模板中的型態 (同樣也是在編譯期間就完成處理) 可以被檢查。\",\"加上這個條件後，因為我們還沒有修改 impl.h，所以照理講他們都是不符合條件的，此時編譯 g++ -std=c++11 t.cpp -o t 會噴以下錯誤訊息：\",\"In file included from t.cpp:3:0: lib.h: In instantiation of ‘double derivative_of(double) [with F = Square; G = Exp]’: t.cpp:9:44: required from here lib.h:10:3: error: static assertion failed: F should be a Function static_assert(std::is_base_of<Function, F>::value, \\\"F should be a Function\\\"); ^~~~~~~~~~~~~ lib.h:11:3: error: static assertion failed: G should be a Function static_assert(std::is_base_of<Function, G>::value, \\\"G should be a Function\\\"); ^~~~~~~~~~~~~ lib.h: In instantiation of ‘double derivative_of(double) [with F = Exp; G = Square]’: t.cpp:13:44: required from here lib.h:10:3: error: static assertion failed: F should be a Function static_assert(std::is_base_of<Function, F>::value, \\\"F should be a Function\\\"); ^~~~~~~~~~~~~ lib.h:11:3: error: static assertion failed: G should be a Function static_assert(std::is_base_of<Function, G>::value, \\\"G should be a Function\\\"); ^~~~~~~~~~~~~\",\"因此我們需要再調整一下 Square 跟 Exp 才能滿足我們剛剛給定的條件：\",\"// impl.h #pragma once #include <cmath> #include \\\"base.h\\\" template<typename T> struct traits; class Square: public Function {}; class Exp: public Function {}; template<> struct traits<Square> { static double of(double x) { return x * x; } static double derivative_of(double x) { return 2 * x; } }; template<> struct traits<Exp> { static double of(double x) { return exp(x); } static double derivative_of(double x) { return of(x); } };\",\"但是這個招數不是萬能的，除了方法的侷限 (你總不能叫 int 也繼承自 Function，他只是型態不是類別) 外，他強制了該模板的型態必須具備相同的繼承關係，而不是強制他必須具備某種「結構」或「特性」。就這個角度來說，比起限制類型的繼承關係，限制他是否擁有這個函數顯然更靠譜一些。\",\"抱持著這個想法，我們換個做法：\",\"#pragma once #include <type_traits> template<typename T> struct traits; template <typename T> class has_of { typedef char expected; struct not_expected { char x[2]; }; template <typename C> static expected test( decltype(traits<C>::of(std::declval<double>())) ); template <typename C> static not_expected test(...) { return 0; }; public: enum { value = sizeof(test<T>(0)) == sizeof(expected) }; }; template <typename T> class has_derivative_of { typedef char expected; struct not_expected { char x[2]; }; template <typename C> static expected test( decltype(traits<C>::derivative_of(std::declval<double>())) ); template <typename C> static not_expected test(...); public: enum { value = sizeof(test<T>(0)) == sizeof(expected) }; }; template<typename F, typename G> double derivative_of(double x) { static_assert(has_of<F>::value, \\\"F should implement the member function `double of(double)`.\\\"); static_assert(has_of<G>::value, \\\"G should implement the member function `double of(double)`.\\\"); static_assert(has_derivative_of<F>::value, \\\"F should implement the member function `double derivative_of(double)`.\\\"); static_assert(has_derivative_of<G>::value, \\\"G should implement the member function `double derivative_of(double)`.\\\"); return traits<F>::derivative_of( traits<G>::of(x) ) * traits<G>::derivative_of(x); }\",\"這次我們利用了 SFINAE (替換失敗並非錯誤, substitution failure is not an error) 去判斷型態是否有指定的靜態函數 of 與 derivative_of，此時我們就不需要局限於繼承的手法，而且可以執行更精準的判斷。\",\"Tips\",\"留意到目前階段我們只有檢查函數是否存在，但還沒有檢查輸出格式。\",\"在本篇我們大致了解 C++ trait 的想法以及實現方式，除了我們可以更順暢地閱讀外面的一些實作，免得說出現「我不知道他在寫什麼鬼東西哭阿」的這種窘境之外，也可以讓我們未來在實作 C++ 相關專案的時候，手上可以有更多的工具或手法讓專案更簡潔或更強健！\",\"Standard library header <type_traits> - cppreference.com\",\"An introduction to C++ Traits - ACCU Blog\",\"Templated check for the existence of a class member function - Stack Overflow\"]},\"9\":{\"h\":\"Checking Sum of Squares (SOS) Polynomials with CVXPY\",\"t\":[\"This post aims at introducing a programming way to check if a polynomial is sum of squares.\"]},\"10\":{\"h\":\"Background Knowledge of Sum of Squares Polynomials\",\"t\":[\"Formally we say a polynomial is sum of squares if exist several polynomials such that\",\"It is well-known that a polynomial of maximum total degree is sum of squares if and only if there is a positive semidefinite matrix such that\",\"where is a vector of monomial basis with maximum total degree .\",\"This property allows us to check if an unknwon polynomial is sum of squares, by performing a semidefinite programming.\"]},\"11\":{\"h\":\"Semidefinite Programming by Python\",\"t\":[\"From here we use SymPy for algebraic calculation and CVXPY for semidefinite programming.\",\"This program (in primal form) does not need any energy function since we only check the feasibility under constraints .\",\"For example, if our testing funtion is\",\"then firstly we construct the polynomial\",\"from collections import defaultdict import sympy as smp from sympy.abc import x, y, z gens = [x, y, z] f = 2 _ x**4 - 5 / 2 _ x**3 * y + x**2 _ y _ z - 2 _ x _ z**3 + 5 * y**4 + z**4 f = f.as_poly(gens) # rewrite polynomial as defaultdict format f_poly = defaultdict(int) for monom, coeff in zip(f.monoms(), f.coeffs()): f_poly[monom] += coeff\",\"and corresponding (expected) sum of squares representation\",\"Tips\",\"import numpy as np from sympy.polys.monomials import itermonomials import cvxpy as cp max_degree = np.max(np.sum(np.array(f.monoms()), axis=1)) total_degree = int(np.ceil(max_degree / 2)) monolist = list(itermonomials(gens, total_degree)) z = np.array(list(map(lambda x: x.as_poly(gens).monoms()[0], monolist))) z_left = np.tile(z[:, np.newaxis, :], (1, z.shape[0], 1)) z_right = np.tile(z[np.newaxis, :, :], (z.shape[0], 1, 1)) gram = z_left + z_right monom_degree = len(monolist) matrix = cp.Variable((monom_degree, monom_degree), name='Q', PSD=True) sos_poly = defaultdict(int) for i in range(monom_degree): for j in range(monom_degree): monom = tuple(gram[i, j]) sos_poly[monom] += matrix[i, j]\",\"Now we would like to subtract the target polynomial by polynomial constructed by a positive semidefinite matrix, and forced the result function to be zero.\",\"constraint_poly = sos_poly.copy() for monom, coeff in f_poly.items(): constraint_poly[monom] -= coeff constraints = [] for coeff in constraint_poly.values(): if not isinstance(coeff, int) and not isinstance(coeff, float): constraints.append(coeff == 0)\",\"Finally we construct the corresponding problem and solve it.\",\"problem = cp.Problem(cp.Minimize(0), constraints=constraints) problem.solve(solver='MOSEK', verbose=True)\",\"For this example we obtain the following result:\",\"Problem Name : Objective sense : min Type : CONIC (conic optimization problem) Constraints : 135 Cones : 0 Scalar variables : 55 Matrix variables : 1 Integer variables : 0 Optimizer - threads : 6 Optimizer - solved problem : the primal Optimizer - Constraints : 100 Optimizer - Cones : 1 Optimizer - Scalar variables : 21 conic : 21 Optimizer - Semi-definite variables: 1 scalarized : 55 Factor - setup time : 0.00 dense det. time : 0.00 Factor - ML order time : 0.00 GP order time : 0.00 Factor - nonzeros before factor : 5050 after factor : 5050 Factor - dense dim. : 0 flops : 3.73e+05 ITE PFEAS DFEAS GFEAS PRSTATUS POBJ DOBJ MU TIME 0 4.0e+00 1.0e+00 1.0e+00 0.00e+00 0.000000000e+00 0.000000000e+00 1.0e+00 0.00 1 9.9e-01 2.5e-01 2.6e-01 -5.06e-01 0.000000000e+00 5.955154109e-01 2.5e-01 0.00 2 1.2e-01 3.1e-02 8.9e-03 6.55e-01 0.000000000e+00 1.786795893e-02 3.1e-02 0.00 3 2.4e-02 6.0e-03 6.4e-04 1.16e+00 0.000000000e+00 -1.171957303e-04 6.0e-03 0.00 4 4.8e-03 1.2e-03 6.3e-05 1.02e+00 0.000000000e+00 4.984738046e-04 1.2e-03 0.00 5 1.0e-03 2.6e-04 6.2e-06 1.22e+00 0.000000000e+00 1.448269790e-04 2.6e-04 0.00 6 2.5e-04 6.2e-05 7.6e-07 1.10e+00 0.000000000e+00 4.819535948e-05 6.2e-05 0.00 7 5.7e-05 1.4e-05 8.2e-08 1.12e+00 0.000000000e+00 1.182936817e-05 1.4e-05 0.01 8 1.2e-05 2.9e-06 7.3e-09 9.73e-01 0.000000000e+00 1.623429926e-06 2.9e-06 0.01 9 2.3e-06 5.7e-07 6.3e-10 8.44e-01 0.000000000e+00 2.578343391e-07 5.7e-07 0.01 10 5.6e-07 1.4e-07 7.0e-11 1.22e+00 0.000000000e+00 4.849970349e-08 1.4e-07 0.01 11 1.3e-07 3.2e-08 9.2e-12 7.81e-01 0.000000000e+00 2.734660260e-08 3.2e-08 0.01 12 2.3e-08 5.8e-09 5.5e-13 1.24e+00 0.000000000e+00 5.578862505e-10 5.8e-09 0.01 Optimizer terminated. Time: 0.01 Interior-point solution summary Problem status : PRIMAL_AND_DUAL_FEASIBLE Solution status : OPTIMAL Primal. obj: 0.0000000000e+00 nrm: 5e+00 Viol. con: 3e-08 var: 0e+00 barvar: 0e+00 Dual. obj: 5.5788624960e-10 nrm: 4e+00 Viol. con: 0e+00 var: 3e-09 barvar: 9e-09\",\"which is feasibile.\",\"Now we consider another function . Obviously this is not a sum of squares polynomial. In this case we follow the above procedure and we can get the following result\",\"Problem Name : Objective sense : min Type : CONIC (conic optimization problem) Constraints : 26 Cones : 0 Scalar variables : 10 Matrix variables : 1 Integer variables : 0 Optimizer - threads : 6 Optimizer - solved problem : the primal Optimizer - Constraints : 16 Optimizer - Cones : 0 Optimizer - Scalar variables : 0 conic : 0 Optimizer - Semi-definite variables: 1 scalarized : 10 Factor - setup time : 0.00 dense det. time : 0.00 Factor - ML order time : 0.00 GP order time : 0.00 Factor - nonzeros before factor : 136 after factor : 136 Factor - dense dim. : 0 flops : 2.36e+03 ITE PFEAS DFEAS GFEAS PRSTATUS POBJ DOBJ MU TIME 0 1.0e+00 1.0e+00 1.0e+00 0.00e+00 0.000000000e+00 0.000000000e+00 1.0e+00 0.00 1 7.9e-02 7.9e-02 1.8e-01 -2.00e-01 0.000000000e+00 4.850239930e+00 7.9e-02 0.00 2 6.8e-05 6.8e-05 8.0e-03 -9.73e-01 0.000000000e+00 1.400490086e+04 6.8e-05 0.00 3 3.4e-14 3.4e-14 1.3e-07 -1.00e+00 0.000000000e+00 1.431945428e+13 3.4e-14 0.00 Optimizer terminated. Time: 0.00 MOSEK PRIMAL INFEASIBILITY REPORT. Problem status: The problem is primal infeasible The following constraints are involved in the primal infeasibility. Index Name Lower bound Upper bound Dual lower Dual upper 0 0.000000e+00 0.000000e+00 0.000000e+00 1.143887e+00 1 1.000000e+00 1.000000e+00 2.374090e-01 0.000000e+00 2 1.000000e+00 1.000000e+00 2.374090e-01 0.000000e+00 3 1.000000e+00 1.000000e+00 2.374090e-01 0.000000e+00 4 0.000000e+00 0.000000e+00 0.000000e+00 1.047962e+00 5 0.000000e+00 0.000000e+00 0.000000e+00 4.796219e-02 6 0.000000e+00 0.000000e+00 0.000000e+00 4.796219e-02 7 0.000000e+00 0.000000e+00 0.000000e+00 1.047962e+00 8 0.000000e+00 0.000000e+00 0.000000e+00 4.796219e-02 9 0.000000e+00 0.000000e+00 0.000000e+00 1.047962e+00 10 0.000000e+00 0.000000e+00 0.000000e+00 1.143887e+00 11 0.000000e+00 0.000000e+00 4.500538e-01 0.000000e+00 12 0.000000e+00 0.000000e+00 4.500596e-01 0.000000e+00 13 0.000000e+00 0.000000e+00 4.500537e-01 0.000000e+00 14 0.000000e+00 0.000000e+00 2.476412e-02 0.000000e+00 15 0.000000e+00 0.000000e+00 0.000000e+00 1.047962e+00 16 0.000000e+00 0.000000e+00 0.000000e+00 8.414647e-02 17 0.000000e+00 0.000000e+00 0.000000e+00 8.412991e-02 18 0.000000e+00 0.000000e+00 2.475832e-02 0.000000e+00 19 0.000000e+00 0.000000e+00 0.000000e+00 1.177790e-02 20 0.000000e+00 0.000000e+00 0.000000e+00 1.047962e+00 21 0.000000e+00 0.000000e+00 0.000000e+00 8.416118e-02 22 0.000000e+00 0.000000e+00 2.476425e-02 0.000000e+00 23 0.000000e+00 0.000000e+00 0.000000e+00 1.179446e-02 24 0.000000e+00 0.000000e+00 0.000000e+00 1.176319e-02 25 0.000000e+00 0.000000e+00 0.000000e+00 1.047962e+00 The following bound constraints are involved in the infeasibility. Index Name Lower bound Upper bound Dual lower Dual upper Dual cone Interior-point solution summary Problem status : PRIMAL_INFEASIBLE Solution status : PRIMAL_INFEASIBLE_CER Dual. obj: 7.1222688931e-01 nrm: 1e+00 Viol. con: 0e+00 var: 0e+00 barvar: 3e-14\",\"which is infeasible.\"]},\"12\":{\"h\":\"Conclusion\",\"t\":[\"From this post we are able to check if a function is a sum of squares polynomial by performing a corresponding semidefinite programming. It means that we do not need to find such polynomials manually but just simply run some optimization algorithm (e.g. interior-point method). However we note that the matrix space complexity w.r.t. total degree is exponential.\"]},\"13\":{\"h\":\"References\",\"t\":[\"Sum-of-squares programming - YALMIP\",\"SymPy\",\"CVXPY\"]},\"14\":{\"h\":\"Context Management in Python\",\"t\":[\"在執行程式的時候通常會需要存取資源，一般來說資源的來源可能是檔案、遠端連線、或是某種 Socket。當程式在調用資源的時候基本上包含兩個動作：\",\"請求資源使用權 (以檔案來說就是讀或寫之類的)、以及\",\"釋放資源使用權。\",\"本篇我們將整理在 Python 中面對資源存取問題時，透過 with 的常見作法、其物件意涵、以及內建套件 contextlib 的一些使用時機。\"]},\"15\":{\"h\":\"單一檔案存取\",\"t\":[\"假設我們有一個檔案 input.txt：\",\"Hello world! I am a file. This is a new line.\",\"透過 Python 我們可以透過以下程式碼實現讀檔並輸出到終端機上：\",\"# access `input.txt` file with reading permission obj = open('input.txt', 'r') # read content and print to stdout print(obj.read()) # release file resource obj.close()\",\"而透過 with 關鍵字可以幫助程式碼在這個過程中更簡潔：\",\"with open('input.txt', 'r') as f: print(f.read())\",\"到目前為止是大家在學習 Python 的時候幾乎會碰觸到的課題，接下來我們將討論 with 在 Python 當中的物件意涵。\",\"我們同樣盯著上面的範例程式碼看，實際上他相當於以下語法結構：\",\"import sys # with open('input.txt', 'r') as f: obj = open('input.txt', 'r') f = obj.__enter__() exc = True # a flag to determine if process trap into the except block try: # inside the with block print(f.read()) except: # go to here if there is an exception happened inside the block # set flag as False to avoid double-free exc = False # collect exception information exc_type, exc_val, exc_tb = sys.exit_info() if not obj.__exit__(exc_type, exc_val, exc_tb): raise finally: if exc: # in this way there is no exception exc_type = exc_val = exc_tb = None obj.__exit__(exc_type, exc_val, exc_tb)\",\"在這段程式碼中，我們會發現：\",\"在進入 with 區塊前，Python 會初始化 obj 物件並觸發 __enter__ 方法以存取資源，並且將其回傳值賦予到 f；\",\"而當程序離開 with 區塊時，Python 會觸發 obj 物件的 __exit__ 方法以釋放資源。\",\"Tips\",\"在檔案的例子中，obj.__enter__ 的回傳值實際上就是物件 obj 本身，而 obj.__exit__ 方法就相當於呼叫 obj.close 方法。\",\"事情似乎變得複雜起來，但理解這個機制後，我們可以結合 Python 本身的 duck typing 特性 去做更彈性的編排。舉例來說，我們可以自定義一種類別，使得在檔案資源存取的時候結合計數器功能：\",\"class FileResource(object): # counting times of reading and writing write_count = 0 read_count = 0 def __init__(self, filename, mode): self.filename = filename self.mode = mode self.file = None # will be triggered when process enter the with block def __enter__(self): # handling counter if 'w' in self.mode: FileResource.write_count += 1 if 'r' in self.mode: FileResource.read_count += 1 # instantiate file object and return itself self.file = open(self.filename, self.mode) return self.file # will be triggered when process leave the with block def __exit__(self, exc_type, exc_val, exc_tb): # when exception raised inside the with block, `exc_type` would be the # type of the exception, `exc_val` would be the object of such type, # and `exc_tb` would be the object of TracebackType. # # return True if you want to surpress this exception return self.file.__exit__(exc_type, exc_val, exc_tb) if __name__ == '__main__': with FileResource('input.txt', 'w') as f: f.write('Hello world! I am a file.\\\\nThis is a new line.') with FileResource('input.txt', 'r') as f: print('first time reading ...') with FileResource('input.txt', 'r') as f: print('second time reading ...') print('instantiate but not actually read ...') fr = FileResource('input.txt', 'r') print(FileResource.read_count, FileResource.write_count)\",\"在執行結果中，我們會發現計數器有成功的被運作，且當檔案沒有真正開啟時不會列入計數。\",\"first time reading ... second time reading ... instantiate but not actually read ... 2 1\",\"此時我們已經具備設計自定義資源管理器的基礎技能了，現在我們要藉由 Python 強大內建套件來實現更靈活的操作。\"]},\"16\":{\"h\":\"使用 contextlib\",\"t\":[\"這個強大內建套件就是 contextlib，實務上他可以幫助 Python 在處理資源管理的時候可以更加優雅。\",\"我們以 FileResource 為例，在 contextlib 的加持下它可以被簡化成以下形式：\",\"import contextlib write_count = 0 read_count = 0 @contextlib.contextmanager def FileResource(filename, mode): if 'w' in mode: global write_count write_count += 1 if 'r' in mode: global read_count read_count += 1 obj = open(filename, mode) try: yield obj except: # you can handle exception here raise finally: obj.close() if __name__ == '__main__': with FileResource('input.txt', 'w') as f: f.write('Hello world! I am a file.\\\\nThis is a new line.') with FileResource('input.txt', 'r') as f: print('first time reading ...') with FileResource('input.txt', 'r') as f: print('second time reading ...') print('instantiate but not actually read ...') fr = FileResource('input.txt', 'r') print(FileResource.read_count, FileResource.write_count)\",\"此時會發現說我們不用自行宣告類別就可以實現同樣的功能，且不只是更短的行數，程式碼的邏輯也變得更清晰。\",\"以下我們透過一些案例來介紹 contextlib 的一些使用方法、以及額外功能。\"]},\"17\":{\"h\":\"Case Study #1: 包裝函數\",\"t\":[\"當有些語法比較彆扭的時候可以包裝起來讓程式更美觀\",\"import contextlib import asyncssh def get_host_info_by_config(config): ... @contextlib.contextmanger def open_connect_by_config(config): hostname, username = get_host_info_by_config(config) with asyncssh.connect(hostname, username=username) as conn: yield conn\"]},\"18\":{\"h\":\"Case Study #2: 轉導 stdout 到檔案流\",\"t\":[\"將在 stdout 接到的字串流當作資源，轉導引到其他檔案流 (如空裝置或標準錯誤流)。\",\"import contextlib import os import sys with contextlib.redirect_stdout(None): print('Do not show anything') with contextlib.redirect_stdout(sys.stderr): print('I would be flushed at any time!')\",\"Warning\",\"Python 的 redirect_stdout 並無法捕捉所有 stdout 接收到的字串流，就算是 sys.stdout 也有同樣的問題，若要捕捉全部資料，需要去呼叫到底層的 file descriptor. 若有興趣的讀者請參考 Eli Bendersky： Redirecting all kinds of stdout in Python.\"]},\"19\":{\"h\":\"Case Study #3: 複數資源管理 ExitStack\",\"t\":[\"複數資源的調用過程相當於 stack 的操作過程\",\"contextlib 已經實作好了，不要重造輪子\",\"import contextlib filenames = ['input1.txt', 'input2.txt', 'input3.txt'] with contextlib.ExitStack() as stack: files = [stack.enter_context(open(fname)) for fname in filenames] # do something ...\"]},\"20\":{\"h\":\"資源管理的深層應用\",\"t\":[\"在上面的案例中的資源都是十分具體的，比如說一個檔案或是一個流，而透過上述程式碼所形成的結構我們都可以稱作資源管理，意思是說「資源」也可以是一個抽象概念，比如說一個程式執行的狀態。\",\"Tips\",\"或者直接將這個結構理解成：對內部區塊程式碼的前處理及後處理方法也可以。\",\"這樣的想法實際上也被應用在 Python 中的許多場景，舉例來說：\",\"unittest.assertRaises 方法可以幫助使用者單元測試一程式碼片段是否會跳出預期錯誤，但又不會讓程序中斷。\",\"unittest.subTest 方法可以幫助使用者強制執行子測試當中的所有測試，即使中間出錯也會執行到底。\",\"contextlib.suppress 方法可以幫助程序不中斷特定錯誤。\"]},\"21\":{\"h\":\"結論\",\"t\":[\"理解 Python 的資源管理後，一方面可以讓我們在之後使用 with 的時候可以更有自信，另一方面也可以更加體會 Python 的一些機制、認識好用的內建套件、建立對 Python 更正確的認知、進而撰寫更漂亮的程式結構。\"]},\"22\":{\"h\":\"References\",\"t\":[\"PEP 0343 -- The \\\"with\\\" Statement\",\"contextlib — Utilities for with-statement contexts\",\"unittest — Unit testing framework\"]},\"23\":{\"h\":\"Python 加速符文：高效能平行科學計算\",\"t\":[\"在 Python 基礎科學運算中，我們習於使用 NumPy 以方便且快速地實現矩陣運算，然而在部分情境下仍會遇到效能瓶頸。舉例來說，我們利用 NumPy 線性代數模組處理一個大型線性最小平方問題，但效能瓶頸卻發生在使用原生 Python 迴圈建造矩陣的過程。在本文中，我們將探討 Python 效能瓶頸問題，並試圖使用一些現有工具去達成運算加速的目的，同時比較這些工具之間的特性。\"]},\"24\":{\"h\":\"Python 為什麼那麼慢？\",\"t\":[\"Python 好香，但他好慢 🥲\",\"為什麼使用 Python 的理由很簡單，一來他語法親民，能夠快速實現並測試一些功能或者想法；二來他有很多方便、隨裝即用的套件，使用者往往不需要太多的功夫就能達成許多新鮮有趣的程式。\",\"然而眾所皆知， Python 很慢，但也不代表說我們只能乾瞪眼任其一直慢下去。所謂了解問題是解決問題的第一步，不過我們需要分一點層次去探討他慢的理由。以下會用比較簡易的方式進行探討，關於完整的效能議題可以參考 [1]。\",\"Tips\",\"在本文中我們以 CPU-tasks 為主，關於 I/O-tasks 的效能問題則有不同的處理手段。\"]},\"25\":{\"h\":\"\",\"t\":[\"動態型別 (Dynamically typed) 的意思是說，我們不需要為變數指定他的型態，同時我們可以對相同的變數名賦予完全不同型態的值。比如說以下程式碼：\",\"a = 1 # type(a) == int a = \\\"123\\\" # type(a) == str\",\"在第一行時，變數 a 的型態為整數 1，而在第二行時，變數 a 的型態變成字串 \\\"123\\\"，且在變數宣告過程中，我們都沒有提示說該變數的型態為何。\",\"相比之下，在靜態型別 (Statically typed) 語言中，像是 C++ 或 Java ，你就必須得這麼做：\",\"int a = 1; // std::string a = \\\"123\\\"; // You even can't do this std::string b = \\\"123\\\";\",\"如此乍看之下，擁有動態型別特性的語言能帶給我們更大的彈性，並且方便！但是，這個便利性是有代價的。\"]},\"26\":{\"h\":\"Python 是直譯型語言\",\"t\":[\"與編譯型 (Compiled) 語言不同的是，直譯型 (Interpreted) 語言會將程式碼編譯成位元組碼 (bytecode)，接著再將位元組碼提供給直譯器 (interpreter)，讓他轉換成最終的機械碼 (machine code)，也就是 CPU 真正看得懂的語言。\",\"這樣乍看下來，在執行階段中，直譯型語言就硬生生比編譯型語言多出了編譯的成本，因為編譯型語言在執行階段就是讀機械碼，不須多加編譯或解析。這個說法本身並沒有錯，但是 Python 慢的主要理由並不只是這裡。一個例子是 Java ，他的編譯過程也是將原始碼轉成位元組碼，並於執行階段再將其交由 JVM 去轉換成機械碼，但 Java 事實上並沒有那麼慢。\",\"真正的問題是動態型別！自由自在的型態使得程式碼的運作行為無法輕易地被預期，因此直譯器必須要逐步執行並逐步判斷接下來的運算行為。就好比程式執行的過程像是火車在前進，在已知型態的前提下，我們可以事先將軌道鋪得遠一些，讓火車不用走走停停的，但 Python 只能讓火車走一步停一步，等軌道鋪好一格後才能繼續走。\",\"到目前為止，我們對於 Python 的效能問題有以下簡單的見解：動態型別的特性逼得 Python 需要設計成直譯型語言，而動態型別的不可預期性讓效能在執行階段難以被優化。\"]},\"27\":{\"h\":\"Python 有全域直譯器鎖\",\"t\":[\"Python 使用 reference counting 的方式管理記憶體，並以此作為垃圾回收機制以及記憶體管理的基礎。\",\"這使得說每個變數的計數器在多線程處理中需要被保護，意思是說直譯器需要確保變數在每個時刻下只被一個線程控制 (這意味著新增或者減少參考計數)，在 Python 中，他的做法就是引進全域直譯器鎖 (Global Interpreter Lock)，強迫在任何時刻下都只有一個線程在運作。\",\"這也是 Python 效能變得不是很優的原因之一，但僅限在多線程處理中才會遇到：本來好端端能平行運算的東西，因為記憶體管理的因素，而被迫降級成實質單線程運算的品質。\",\"Tips\",\"變數的參考計數實際上比你想像中更頻繁得被更動，我們用以下例子說明：\",\"a = 10000000000000000 # import gc; len(gc.get_referrers(a)) == 1 b = a # len(gc.get_referrers(a)) == 2 c = a # len(gc.get_referrers(a)) == 3\",\"在程式碼中，第一行宣告變數 a 時，該物件 10000000000000000 會被初始化，並且該計數器為 1 ，當程式執行到第二行時，同樣的物件看似沒有被修改，但他的計數器會加一，因此實質上它的內部數值還是被修改了。\",\"由此可知，第二行跟第三行即使平行化了也不能同步執行，雖然這聽起來很不可理喻，但 Python 就是這樣。\"]},\"28\":{\"h\":\"加速符文\",\"t\":[\"到目前為止，我們大致理解 Python 效能問題的主要理由，總算可以來談談如何進行加速了，但這邊還是得先打個預防針：凡好康的福利總是有前提的。\",\"在本文中，我們著重於科學計算 (或者說數值計算) 的加速，為了方便進行不同工具間的比較，我們使用相同的數值計算問題 (弧長計算) 進行演示：給定一個有限數列\",\"我們想要計算出這個數列所形成的弧長\",\"如果用 NumPy 實作這個功能的話，我們可以使用以下程式碼：\",\"# with_numpy/lib.py import numpy as np def arc_length(points: np.ndarray) -> float: \\\"\\\"\\\"Compute the arc length of a discrete set of points (curve). Args: points (np.ndarray): A list of points. Returns: float: Arc length. \\\"\\\"\\\" piecewice_length = np.linalg.norm(np.diff(points, axis=0), axis=1) return np.sum(piecewice_length)\",\"其中我們將數列表達成一個二維陣列，其中每一列代表數列中的一個點。\",\"其實這個版本跟原始 Python 相比，效能算是還不錯了，不過以下會告訴大家，這還差得遠。\"]},\"29\":{\"h\":\"基礎加速符文：靜態型別\",\"t\":[\"儘管 Python 是一個動態型別語言，但其實我們沒有那麼需要動態型別。\",\"就弧長計算的例子來說，我們很明確地知道輸入的數列是一個二維向量，且每一個數值都是符點數，因此我們並不會使用到動態型別的優勢。在這邊我們首先介紹第一個工具 Pythran，他提供了為函數參數提供指定型態的功能，並且將程式碼事先編譯 (ahead of time compilation, AOT) 成可由 Python 於執行階段呼叫的 shared library ，進而達成靜態型別的效益 (同時也省去執行階段編譯的成本)。\",\"# with_pythran/lib.py import numpy as np # pythran export arc_length(float64[:, :]) def arc_length(points: np.ndarray) -> float: \\\"\\\"\\\"Compute the arc length of a discrete set of points (curve). Args: points (float64[:, :]): A list of points. Returns: float: Arc length. \\\"\\\"\\\" length = 0 for i in range(points.shape[0] - 1): length += np.linalg.norm(points[i + 1] - points[i]) return length\",\"在這邊可以看到我們透過註解 (第四行) 告訴 Pythran 該函數的唯一參數是一個二維的 64-bit 浮點數陣列 float64[:, :]，除此之外，你可以看到我們並沒有使用到其他特殊的語句。\",\"接著我們可以使用以下指令進行事先編譯：\",\"pythran lib.py\",\"他會在同一層目錄下建立一個名稱類似於 lib.cpython-XXm-x86_64-XXX-XXX.so 的 shared library (在筆者使用的電腦中，該名稱為 lib.cpython-37m-x86_64-linux-gnu.so) ，我們留意到他只能由指定的 Python 版本以及指令集架構呼叫，因為他本身已經是機械碼了。\",\"至此，我們就可以來一窺這個加速符文的功效了：\",\"NumPy v.s.Pythran-NumPy\",\"在這個測試當中，我們在固定數值點的維度 (三維) 下，逐步增加點的數量 (在實際測試中我們試驗一百萬到一千萬個點) ，在這之中我們發現在適當的程式編排下， Pythran 的效能比 NumPy 快了約七倍！由此可見，光是固定變數型態，就足以讓編譯器決定說如何能讓程式效率變得更好。\",\"Tips\",\"實際上也有其他套件能做到類似的事情，一個大家常聽到的工具是 Cython，不過使用者需要熟悉 Cython 自定義的語法，他有點像 C/C++ ，但又有些差異。筆者認為他比較難上手，故不在此篇特別做介紹。\",\"Tips\",\"在上文中，所謂「適當的程式編排」指的是說：程式設計師依然要提供正確且簡潔的實作方法，同時也要考量到套件本身對各式語法的支援程度，如此才能將加速機制發揮到極致。\"]},\"30\":{\"h\":\"中級加速符文：平行處理\",\"t\":[\"在上述測試中，不管是 NumPy 或者是 Pythran 的初步實作，他們在計算上都是只有使用到單一線程。意思是說，到目前為止的執行效能還可以透過平行化再上一層樓。\",\"幸運的是， Pythran 本身也有提供平行化的功能，在這邊我們需要為本來的程式碼加上 OpenMP 的語法註解。\",\"# with_pythran_omp/lib.py import numpy as np # pythran export arc_length(float64[:, :]) def arc_length(points): \\\"\\\"\\\"Compute the arc length of a discrete set of points (curve). Args: points (float64[:, :]): A list of points. Returns: float: Arc length. \\\"\\\"\\\" length = 0 # omp parallel for reduction(+:length) for i in range(points.shape[0] - 1): length += np.linalg.norm(points[i + 1] - points[i]) return length\",\"在以上程式碼中， omp parallel for 是對於 for 迴圈平行化運算的常見起手式，而由於 length 在這個地方是作為累加的單一變數，可能會有所謂的讀寫問題 (readers-writers problems) ，因此我們需要加上 reduction(+:length) 以避免不良的平行化機制。\",\"至此我們再編譯一次，留意我們需要再另外加上 -fopenmp 這個 flag:\",\"pythran -fopenmp lib.py\",\"接著我們就可以來看看在平行化加持下的效果如何：\",\"NumPy v.s. Pythran-NumPy (Single) v.s.Pythran-OpenMP (Parallel)\",\"在六核十二執行緒的執行環境下，一樣的測試場景，在一千萬個點的案例中，我們發現在平行化加持下，效能與單執行緒相比又至多能提升四倍左右！並且在這個實作中，我們已經逐漸逼近 CPU 的運算極限了。\",\"此時或許已經有一些讀者開始思考，有沒有稍微簡單一點的平行化方法呢？\",\"答案是有的！我們在此介紹另外一個強大的工具 Numba，他能夠允許使用者在不涉及到這麼多細節的前提下，一樣能達成類似的效果。我們直接上程式碼：\",\"# with_numba/lib.py import numba as nb import numpy as np @nb.njit(parallel=True) def arc_length(points: np.ndarray) -> float: \\\"\\\"\\\"Compute the arc length of a discrete set of points (curve). Args: points (np.ndarray): A list of points. Returns: float: Arc length. \\\"\\\"\\\" length = 0 for i in nb.prange(points.shape[0] - 1): piecewice_length = np.sqrt(np.sum((points[i + 1] - points[i]) ** 2)) length += piecewice_length return length\",\"在以上實作中，我們利用裝飾器 (Python decorator, @) 對函數進行 Numba 包裝，其中 nb.njit (等價語法為 nb.jit(nopython=True)) 更指定該函數不受 Python interpreter 的介入，使其能夠達到最佳效能。同時我們也指定該函數需要進行平行化，其中我們在第十七行使用 nb.prange 指定該處是可以進行平行化的。\",\"Warning\",\"在 Numba 底層中，他們會自動判斷程式碼並套用合適的平行化機制，不過取而代之，使用者需要透過語法「提示」 Numba 該怎麼做，比如程式碼中的 += 就是一個重要的資訊。詳細的說明可以參考官方文件 [2]。\",\"與 Pythran 不同的是， Numba 透過 just-in-time compilation (JIT) 機制使原始碼在執行階段進行編譯，因此不需要事先編譯。此時我們來看看 Numba 的效果如何：\",\"NumPy v.s. Pythran-NumPy (Single & Parallel) v.s.Numba\",\"在這個比較當中，我們發現他與 Pythran 平行化後的效能相比是足以分庭抗禮的，儘管速度上稍微略遜一小截，但我們觀察到 Numba 能夠提供更高階的語法結構，同時可以留意到我們並沒有特別指定變數型態，雖然他還是只能吃 NumPy 陣列，但 Numba 也會根據當下取得的陣列資訊進行優化，藉以獲得更好的執行彈性。\",\"Tips\",\"Numba 還支援基於 CUDA 的 GPU 加速功能 [3] ，因此他也比 Pythran 還具備更多元的加速方案。\",\"Warning\",\"在上述的效能比較中，我們並沒有將 Numba JIT 編譯的時間納入計算，關於這部分的討論我們會放到後面各類工具比較章節討論。\"]},\"31\":{\"h\":\"\",\"t\":[\"從一開始介紹動態型別、GIL 等等的效能瓶頸問題，到後面我們開始探討說：在科學計算中，我們需要動態型別嗎？需要這種記憶體管理機制嗎？而到目前為止的試驗中我們也發現：將這些緊箍咒一一卸下後，我們也獲得了飛躍的效能提升。\",\"此時我們進一步探討：我們真的有那麼需要 Python 嗎？\",\"這句話的意思是說，我們在上述計算成本大的運算中，似乎壓根沒有從 Python 中得到什麼好處，反而是因為 Python 的設計機制導致我們用了不合理的運算時間才能得到計算結果。那有沒有一種可能性是說，我們在上層呼叫中仍然使用 Python ，但在計算部分我們另起爐灶，用更高效能的語言去實作他呢？\",\"此時我們回過頭來提及上述所使用到的兩個工具 Pythran 跟 Numba ，其實他們已經默默幫我們做到這件事情了。\",\"Pythran 本質上是一個 Python-to-C++ 的轉換器，他真正在做的事情是將 Python 程式碼轉換成 C++ 程式碼，再透過 C++ 編譯器編譯成 shared library 供 Python interpreter 使用；而 Numba 則是使用 LLVM 將 Python 程式碼轉換成高效能的機械碼，基本上也是異曲同工。\",\"不過不可諱言地說，他們在使用上還是受到套件本身的限制，比如說 Numba 無法在函數中塞入 NumPy 以外的套件功能 (e.g., Pandas)，同時他對於 NumPy 語法的支援也有所侷限，在沒有詳細閱讀文件的前提下直接撰寫也有一定的風險 [4]。而相似的困境在 Pythran 中也會遇到 [5]。\",\"Tips\",\"關於 Numba 的使用注意事項以及心得也可以參考 Jacky 的文章 [6]。\",\"那，我們不妨自己寫 C++ 吧？\",\"其實 NumPy 也是在做類似的事情， NumPy 在內部參照了 CPython API 去實現高性能的科學計算功能，當然我們也可以依樣畫葫蘆，同樣對著 CPython API 刻出我們需要的功能，不過 CPython 在不同版本可能會有不同的 API ，這導致我們在實作上會有一點麻煩。\",\"這邊我們介紹 pybind11，他提供了相對 CPython API 而言更上層的語法介面，讓使用者可以更容易得達成這個目的。到這邊我們就實現真正意義上的使用 C++ 了：沒有奇怪的套件限制，同時可以隨意呼叫任何在 C++ 可以使用的函式庫！\",\"// with_pybind11/src/lib.cpp #if __INTELLISENSE__ #undef __ARM_NEON #undef __ARM_NEON__ #endif #include <pybind11/eigen.h> #include <pybind11/numpy.h> #include <pybind11/pybind11.h> #include <omp.h> namespace py = pybind11; int omp_thread_count() { int n = 0; #pragma omp parallel reduction(+:n) n += 1; return n; } double arc_length(Eigen::Ref<Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor>> x) { double length = 0; omp_set_dynamic(0); omp_set_num_threads(omp_thread_count()); #pragma omp parallel for reduction(+:length) for (int i = 1; i < x.rows(); ++i) { length += (x.row(i) - x.row(i - 1)).norm(); } return length; } PYBIND11_MODULE(lib, m) { m.def(\\\"arc_length\\\", &arc_length); }\",\"在這個範例中，我們使用 Eigen 函式庫實現在 C++ 的線性代數運算，他在 C++ 當中也是相當知名的數學套件，同時學習到上面平行化的精神，我們使用 OpenMP 對各線段長的運算進行平行化處理。\",\"Note\",\"參數型態 Eigen::Ref<Eigen::Matrix<...>> 能夠避免函數呼叫中額外進行不必要的複製 (pass-by-reference)，在不使用 Eigen::Ref 的情況下，使用 pybind11 反而可能因為額外的記憶體複製造成效能下降 [7]。\",\"至此，我們對原始碼進行編譯，在這邊我們使用 OpenMP -fopenmp 以及 -O3 編譯優化，最終取得以下效能：\",\"NumPy v.s. Pythran v.s. Numba v.s.pybind11\",\"在這個案例中，我們可以看到 pybind11 與 Pythran 可說不相上下，不過我們切換另一個實驗場景：我們在固定點數量 (一萬點) 的前提下，逐步提升點的維度 (一千維度到一萬維度) ，並比較各方法之間的效能差異：\",\"NumPy v.s. Pythran v.s. Numba v.s.pybind11\",\"在這個範例中，我們看到 pybind11 獲得所有方法中最快的效能，在一萬維度的情況下，速度上甚至是第二名平行化 Pythran 版本的兩倍，與原生 NumPy 相比則是快了超過六十倍，至於最原始的 Python 版本我們就別提了。\",\"雖然我們在這個案例中看到了 pybind11 的潛力，但使用這個方法也並非完全沒有缺點。一個明顯的問題是他需要付上一定的成本去建置相關環境，同時也需要考慮顧慮更多的實作細節，以達到最佳的效能。因此在 Python 平行化運算中並不總是提及 pybind11 這個方案，因為他在產品定位上更接近於一個 Python 綁定器 (Python bindings)。\"]},\"32\":{\"h\":\"\",\"t\":[\"實際上，這些套件他們各自都有自己最關心的議題，故在筆者從開始進行這一系列的測試到現在，並沒有得到所謂「誰才是最佳且唯一解決方案」的結論，而是說我們需要根據當下的實作情境去選擇最適合的工具。因此以下筆者根據自己的使用經驗以及個人感受，提供一個簡易的表格作為套件選擇的依據：\",\"套件\",\"特色\",\"主要限制\",\"適用情境\",\"Cython\",\"Python-to-C/C++ 翻譯器\",\"需學習特規語法\",\"已熟悉 Cython 語法者較佳\",\"Pythran\",\"Python-to-C++ 翻譯器\",\"部分語法不支援\",\"想要透過靜態型別實現效能加速，同時可接受較簡易的平行化方案\",\"Numba\",\"高階科學計算平行化工具\",\"部分語法不支援 (少數用法很彆扭)、初次執行需要等待 JIT 編譯\",\"想要以不改動過多程式碼的前提下實現平行化加速\",\"pybind11\",\"C++ 的 Python 綁定器\",\"需要熟悉 C++，同時也要考慮記憶體複製問題\",\"以 C++ 為套件發展基礎、或者想要追求極致效能、或者單純想炫技 (?)\",\"dask\",\"分散式運算工具，支援大量第三方套件，生態系豐富\",\"參數調整不佳的狀況可能導致效能退步\",\"需要協同各式套件處理大量資料，或者需要進行叢集運算為佳\",\"在表格中我們還另外將 dask 加入比較對象，不過我們沒有將 dask 的效能納入比較對象，除了筆者到目前為止還沒有調出較佳的效能之外，他在使用定位上比較接近叢集運算，這部分就有一點點偏離本篇的主題了，但他仍然是一個非常有趣的套件，若有興趣的讀者可以到他們的官方網站一探究竟。\",\"文末筆者也提供上述測試所使用的 原始碼，若大家閒來無事的話可以參考看看，裡面也有一些本文未提及的暗黑兵法 (例如 CuPy，他是一種 GPU 加速方案)，若讀者有相關疑慮或者建議，也非常歡迎在 Issues 或者本篇留言中回覆！\",\"最後，祝福大家能順利幫自己的程式碼套上適合的加速符文囉！\"]},\"33\":{\"h\":\"References\",\"t\":[\"Mike Huls (2021). Why Python is so slow and how to speed it up, Towards Data Science. ↩︎\",\"Numba. Automatic parallelization with @jit. ↩︎\",\"Numba. Numba for CUDA GPUs. ↩︎\",\"Numba. Supported NumPy features. ↩︎\",\"Pythran. Supported Modules and Functions. ↩︎\",\"Jacky (黃馨平). 魯蛇變蟒蛇, Medium. ↩︎\",\"pybind11. Pass-by-reference for Eigen. ↩︎\"]},\"34\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"35\":{\"h\":\"Projects\"},\"36\":{\"h\":\"Cpp\"},\"37\":{\"h\":\"Posts\"},\"38\":{\"h\":\"Optimization\"},\"39\":{\"h\":\"Python\"}},\"dirtCount\":0,\"index\":[[\"魯蛇變蟒蛇\",{\"1\":{\"33\":1}}],[\"黃馨平\",{\"1\":{\"33\":1}}],[\"↩︎\",{\"1\":{\"33\":7}}],[\"祝福大家能順利幫自己的程式碼套上適合的加速符文囉\",{\"1\":{\"32\":1}}],[\"例如\",{\"1\":{\"32\":1}}],[\"例子如下\",{\"1\":{\"8\":1}}],[\"原始碼\",{\"1\":{\"32\":1}}],[\"文末筆者也提供上述測試所使用的\",{\"1\":{\"32\":1}}],[\"參數調整不佳的狀況可能導致效能退步\",{\"1\":{\"32\":1}}],[\"參數型態\",{\"1\":{\"31\":1}}],[\"生態系豐富\",{\"1\":{\"32\":1}}],[\"支援大量第三方套件\",{\"1\":{\"32\":1}}],[\"分散式運算工具\",{\"1\":{\"32\":1}}],[\"想要以不改動過多程式碼的前提下實現平行化加速\",{\"1\":{\"32\":1}}],[\"想要透過靜態型別實現效能加速\",{\"1\":{\"32\":1}}],[\"初次執行需要等待\",{\"1\":{\"32\":1}}],[\"少數用法很彆扭\",{\"1\":{\"32\":1}}],[\"高階科學計算平行化工具\",{\"1\":{\"32\":1}}],[\"高效能平行科學計算\",{\"0\":{\"23\":1}}],[\"部分語法不支援\",{\"1\":{\"32\":2}}],[\"已熟悉\",{\"1\":{\"32\":1}}],[\"已經實作好了\",{\"1\":{\"19\":1}}],[\"需學習特規語法\",{\"1\":{\"32\":1}}],[\"需要協同各式套件處理大量資料\",{\"1\":{\"32\":1}}],[\"需要熟悉\",{\"1\":{\"32\":1}}],[\"需要這種記憶體管理機制嗎\",{\"1\":{\"31\":1}}],[\"需要設計成直譯型語言\",{\"1\":{\"26\":1}}],[\"需要去呼叫到底層的\",{\"1\":{\"18\":1}}],[\"翻譯器\",{\"1\":{\"32\":2}}],[\"適用情境\",{\"1\":{\"32\":1}}],[\"適當的程式編排\",{\"1\":{\"29\":1}}],[\"主要限制\",{\"1\":{\"32\":1}}],[\"特色\",{\"1\":{\"32\":1}}],[\"特性\",{\"1\":{\"8\":1,\"15\":1}}],[\"套件\",{\"1\":{\"32\":1}}],[\"誰才是最佳且唯一解決方案\",{\"1\":{\"32\":1}}],[\"故在筆者從開始進行這一系列的測試到現在\",{\"1\":{\"32\":1}}],[\"故不在此篇特別做介紹\",{\"1\":{\"29\":1}}],[\"綁定器\",{\"1\":{\"31\":1,\"32\":1}}],[\"版本我們就別提了\",{\"1\":{\"31\":1}}],[\"版本的兩倍\",{\"1\":{\"31\":1}}],[\"版本以及指令集架構呼叫\",{\"1\":{\"29\":1}}],[\"速度上甚至是第二名平行化\",{\"1\":{\"31\":1}}],[\"獲得所有方法中最快的效能\",{\"1\":{\"31\":1}}],[\"逐步提升點的維度\",{\"1\":{\"31\":1}}],[\"逐步增加點的數量\",{\"1\":{\"29\":1}}],[\"最後\",{\"1\":{\"32\":1}}],[\"最終取得以下效能\",{\"1\":{\"31\":1}}],[\"最大的差異是\",{\"1\":{\"5\":1}}],[\"最大的好處在於我們不用重複實作相同的功能\",{\"1\":{\"5\":1}}],[\"函式庫實現在\",{\"1\":{\"31\":1}}],[\"函數等\",{\"1\":{\"6\":1}}],[\"函數中的行為\",{\"1\":{\"6\":1}}],[\"沒有奇怪的套件限制\",{\"1\":{\"31\":1}}],[\"了\",{\"1\":{\"31\":1}}],[\"刻出我們需要的功能\",{\"1\":{\"31\":1}}],[\"吧\",{\"1\":{\"31\":1}}],[\"語法者較佳\",{\"1\":{\"32\":1}}],[\"語法的支援也有所侷限\",{\"1\":{\"31\":1}}],[\"語言會將程式碼編譯成位元組碼\",{\"1\":{\"26\":1}}],[\"語言不同的是\",{\"1\":{\"26\":1}}],[\"語言中\",{\"1\":{\"25\":1}}],[\"無法在函數中塞入\",{\"1\":{\"31\":1}}],[\"則是使用\",{\"1\":{\"31\":1}}],[\"供\",{\"1\":{\"31\":1}}],[\"編譯\",{\"1\":{\"32\":1}}],[\"編譯優化\",{\"1\":{\"31\":1}}],[\"編譯器編譯成\",{\"1\":{\"31\":1}}],[\"編譯的時間納入計算\",{\"1\":{\"30\":1}}],[\"再透過\",{\"1\":{\"31\":1}}],[\"用更高效能的語言去實作他呢\",{\"1\":{\"31\":1}}],[\"那\",{\"1\":{\"31\":1}}],[\"那有沒有一種可能性是說\",{\"1\":{\"31\":1}}],[\"那個皮就好\",{\"1\":{\"6\":1}}],[\"反而可能因為額外的記憶體複製造成效能下降\",{\"1\":{\"31\":1}}],[\"反而是因為\",{\"1\":{\"31\":1}}],[\"反而不是同樣的東西\",{\"1\":{\"6\":1}}],[\"似乎壓根沒有從\",{\"1\":{\"31\":1}}],[\"嗎\",{\"1\":{\"31\":1}}],[\"還具備更多元的加速方案\",{\"1\":{\"30\":1}}],[\"還支援基於\",{\"1\":{\"30\":1}}],[\"藉以獲得更好的執行彈性\",{\"1\":{\"30\":1}}],[\"陣列\",{\"1\":{\"30\":1}}],[\"雖然我們在這個案例中看到了\",{\"1\":{\"31\":1}}],[\"雖然他還是只能吃\",{\"1\":{\"30\":1}}],[\"雖然這聽起來很不可理喻\",{\"1\":{\"27\":1}}],[\"能夠避免函數呼叫中額外進行不必要的複製\",{\"1\":{\"31\":1}}],[\"能夠提供更高階的語法結構\",{\"1\":{\"30\":1}}],[\"能夠快速實現並測試一些功能或者想法\",{\"1\":{\"24\":1}}],[\"平行化運算中並不總是提及\",{\"1\":{\"31\":1}}],[\"平行化後的效能相比是足以分庭抗禮的\",{\"1\":{\"30\":1}}],[\"平行處理\",{\"0\":{\"30\":1}}],[\"機制使原始碼在執行階段進行編譯\",{\"1\":{\"30\":1}}],[\"詳細的說明可以參考官方文件\",{\"1\":{\"30\":1}}],[\"提供一個簡易的表格作為套件選擇的依據\",{\"1\":{\"32\":1}}],[\"提供了一些關於型態的檢查工具\",{\"1\":{\"8\":1}}],[\"提示\",{\"1\":{\"30\":1}}],[\"底層中\",{\"1\":{\"30\":1}}],[\"指定該處是可以進行平行化的\",{\"1\":{\"30\":1}}],[\"指的是說\",{\"1\":{\"29\":1}}],[\"等等的效能瓶頸問題\",{\"1\":{\"31\":1}}],[\"等價語法為\",{\"1\":{\"30\":1}}],[\"等軌道鋪好一格後才能繼續走\",{\"1\":{\"26\":1}}],[\"包裝\",{\"1\":{\"30\":1}}],[\"包裝函數\",{\"0\":{\"17\":1}}],[\"對各線段長的運算進行平行化處理\",{\"1\":{\"31\":1}}],[\"對函數進行\",{\"1\":{\"30\":1}}],[\"對內部區塊程式碼的前處理及後處理方法也可以\",{\"1\":{\"20\":1}}],[\"答案是有的\",{\"1\":{\"30\":1}}],[\"留意我們需要再另外加上\",{\"1\":{\"30\":1}}],[\"留意到目前階段我們只有檢查函數是否存在\",{\"1\":{\"8\":1}}],[\"可說不相上下\",{\"1\":{\"31\":1}}],[\"可以使用的函式庫\",{\"1\":{\"31\":1}}],[\"可以被檢查\",{\"1\":{\"8\":1}}],[\"可能會有所謂的讀寫問題\",{\"1\":{\"30\":1}}],[\"迴圈平行化運算的常見起手式\",{\"1\":{\"30\":1}}],[\"迴圈建造矩陣的過程\",{\"1\":{\"23\":1}}],[\"幸運的是\",{\"1\":{\"30\":1}}],[\"程式設計師依然要提供正確且簡潔的實作方法\",{\"1\":{\"29\":1}}],[\"程式碼\",{\"1\":{\"31\":1}}],[\"程式碼轉換成高效能的機械碼\",{\"1\":{\"31\":1}}],[\"程式碼轉換成\",{\"1\":{\"31\":1}}],[\"程式碼的邏輯也變得更清晰\",{\"1\":{\"16\":1}}],[\"程式碼不見得需要寫在一起\",{\"1\":{\"6\":1}}],[\"自定義的語法\",{\"1\":{\"29\":1}}],[\"自由自在的型態使得程式碼的運作行為無法輕易地被預期\",{\"1\":{\"26\":1}}],[\"光是固定變數型態\",{\"1\":{\"29\":1}}],[\"由此可見\",{\"1\":{\"29\":1}}],[\"由此可知\",{\"1\":{\"27\":1}}],[\"快了約七倍\",{\"1\":{\"29\":1}}],[\"快速複習一下單變數的連鎖律\",{\"1\":{\"7\":1}}],[\"下\",{\"1\":{\"29\":1}}],[\"三維\",{\"1\":{\"29\":1}}],[\"至此我們再編譯一次\",{\"1\":{\"30\":1}}],[\"至此\",{\"1\":{\"29\":1,\"31\":1}}],[\"至於最原始的\",{\"1\":{\"31\":1}}],[\"至於\",{\"1\":{\"6\":1}}],[\"除此之外\",{\"1\":{\"29\":1}}],[\"除了筆者到目前為止還沒有調出較佳的效能之外\",{\"1\":{\"32\":1}}],[\"除了我們可以更順暢地閱讀外面的一些實作\",{\"1\":{\"8\":1}}],[\"除了方法的侷限\",{\"1\":{\"8\":1}}],[\"浮點數陣列\",{\"1\":{\"29\":1}}],[\"該怎麼做\",{\"1\":{\"30\":1}}],[\"該名稱為\",{\"1\":{\"29\":1}}],[\"該函數的唯一參數是一個二維的\",{\"1\":{\"29\":1}}],[\"該物件\",{\"1\":{\"27\":1}}],[\"告訴\",{\"1\":{\"29\":1}}],[\"於執行階段呼叫的\",{\"1\":{\"29\":1}}],[\"於是乎來整理一下他的想法以及實現方法\",{\"1\":{\"5\":1}}],[\"成可由\",{\"1\":{\"29\":1}}],[\"儘管速度上稍微略遜一小截\",{\"1\":{\"30\":1}}],[\"儘管\",{\"1\":{\"29\":1}}],[\"靜態型別\",{\"0\":{\"29\":1}}],[\"給定一個有限數列\",{\"1\":{\"28\":1}}],[\"給定兩個函數\",{\"1\":{\"7\":1}}],[\"進行演示\",{\"1\":{\"28\":1}}],[\"進而達成靜態型別的效益\",{\"1\":{\"29\":1}}],[\"進而撰寫更漂亮的程式結構\",{\"1\":{\"21\":1}}],[\"進而提升程式碼的重複利用度\",{\"1\":{\"5\":1}}],[\"弧長計算\",{\"1\":{\"28\":1}}],[\"凡好康的福利總是有前提的\",{\"1\":{\"28\":1}}],[\"總算可以來談談如何進行加速了\",{\"1\":{\"28\":1}}],[\"第四行\",{\"1\":{\"29\":1}}],[\"第二行跟第三行即使平行化了也不能同步執行\",{\"1\":{\"27\":1}}],[\"第一行宣告變數\",{\"1\":{\"27\":1}}],[\"時\",{\"1\":{\"27\":1}}],[\"時認識到這個用法\",{\"1\":{\"7\":1}}],[\"效能與單執行緒相比又至多能提升四倍左右\",{\"1\":{\"30\":1}}],[\"效能算是還不錯了\",{\"1\":{\"28\":1}}],[\"效能問題的主要理由\",{\"1\":{\"28\":1}}],[\"效能變得不是很優的原因之一\",{\"1\":{\"27\":1}}],[\"效能瓶頸問題\",{\"1\":{\"23\":1}}],[\"強迫在任何時刻下都只有一個線程在運作\",{\"1\":{\"27\":1}}],[\"強大內建套件來實現更靈活的操作\",{\"1\":{\"15\":1}}],[\"事實上並沒有那麼慢\",{\"1\":{\"26\":1}}],[\"事情似乎變得複雜起來\",{\"1\":{\"15\":1}}],[\"慢的主要理由並不只是這裡\",{\"1\":{\"26\":1}}],[\"真正的問題是動態型別\",{\"1\":{\"26\":1}}],[\"真正看得懂的語言\",{\"1\":{\"26\":1}}],[\"真的是滿直觀的\",{\"1\":{\"5\":1}}],[\"讓使用者可以更容易得達成這個目的\",{\"1\":{\"31\":1}}],[\"讓火車不用走走停停的\",{\"1\":{\"26\":1}}],[\"讓他轉換成最終的機械碼\",{\"1\":{\"26\":1}}],[\"讓其他型態繼承\",{\"1\":{\"8\":1}}],[\"直譯型語言就硬生生比編譯型語言多出了編譯的成本\",{\"1\":{\"26\":1}}],[\"直譯型\",{\"1\":{\"26\":1}}],[\"直接定義在\",{\"1\":{\"7\":1}}],[\"擁有動態型別特性的語言能帶給我們更大的彈性\",{\"1\":{\"25\":1}}],[\"像是\",{\"1\":{\"25\":1}}],[\"相比則是快了超過六十倍\",{\"1\":{\"31\":1}}],[\"相比\",{\"1\":{\"28\":1}}],[\"相比之下\",{\"1\":{\"25\":1}}],[\"相關專案的時候\",{\"1\":{\"8\":1}}],[\"變數的參考計數實際上比你想像中更頻繁得被更動\",{\"1\":{\"27\":1}}],[\"變數\",{\"1\":{\"25\":2}}],[\"動態型別的特性逼得\",{\"1\":{\"26\":1}}],[\"動態型別\",{\"1\":{\"25\":1}}],[\"動態的檢查\",{\"1\":{\"8\":1}}],[\"關於這部分的討論我們會放到後面各類工具比較章節討論\",{\"1\":{\"30\":1}}],[\"關於\",{\"1\":{\"24\":1,\"31\":1}}],[\"關於完整的效能議題可以參考\",{\"1\":{\"24\":1}}],[\"關鍵字可以幫助程式碼在這個過程中更簡潔\",{\"1\":{\"15\":1}}],[\"所謂\",{\"1\":{\"29\":1}}],[\"所謂了解問題是解決問題的第一步\",{\"1\":{\"24\":1}}],[\"所以照理講他們都是不符合條件的\",{\"1\":{\"8\":1}}],[\"所以我們有\",{\"1\":{\"7\":1}}],[\"所以他們還是需要一起編譯\",{\"1\":{\"6\":1}}],[\"很慢\",{\"1\":{\"24\":1}}],[\"隨裝即用的套件\",{\"1\":{\"24\":1}}],[\"二來他有很多方便\",{\"1\":{\"24\":1}}],[\"🥲\",{\"1\":{\"24\":1}}],[\"好香\",{\"1\":{\"24\":1}}],[\"同樣對著\",{\"1\":{\"31\":1}}],[\"同樣的物件看似沒有被修改\",{\"1\":{\"27\":1}}],[\"同樣也是在編譯期間就完成處理\",{\"1\":{\"8\":1}}],[\"同時可接受較簡易的平行化方案\",{\"1\":{\"32\":1}}],[\"同時可以隨意呼叫任何在\",{\"1\":{\"31\":1}}],[\"同時可以留意到我們並沒有特別指定變數型態\",{\"1\":{\"30\":1}}],[\"同時學習到上面平行化的精神\",{\"1\":{\"31\":1}}],[\"同時他對於\",{\"1\":{\"31\":1}}],[\"同時我們也指定該函數需要進行平行化\",{\"1\":{\"30\":1}}],[\"同時我們可以對相同的變數名賦予完全不同型態的值\",{\"1\":{\"25\":1}}],[\"同時也要考慮記憶體複製問題\",{\"1\":{\"32\":1}}],[\"同時也要考量到套件本身對各式語法的支援程度\",{\"1\":{\"29\":1}}],[\"同時也需要考慮顧慮更多的實作細節\",{\"1\":{\"31\":1}}],[\"同時也省去執行階段編譯的成本\",{\"1\":{\"29\":1}}],[\"同時比較這些工具之間的特性\",{\"1\":{\"23\":1}}],[\"線性代數模組處理一個大型線性最小平方問題\",{\"1\":{\"23\":1}}],[\"然而眾所皆知\",{\"1\":{\"24\":1}}],[\"然而在部分情境下仍會遇到效能瓶頸\",{\"1\":{\"23\":1}}],[\"然而這邊\",{\"1\":{\"8\":1}}],[\"基本上也是異曲同工\",{\"1\":{\"31\":1}}],[\"基本上是在講同樣的東西\",{\"1\":{\"6\":1}}],[\"基礎加速符文\",{\"0\":{\"29\":1}}],[\"基礎科學運算中\",{\"1\":{\"23\":1}}],[\"加入比較對象\",{\"1\":{\"32\":1}}],[\"加速方案\",{\"1\":{\"32\":1}}],[\"加速功能\",{\"1\":{\"30\":1}}],[\"加速符文\",{\"0\":{\"23\":1,\"28\":1}}],[\"加上這個條件後\",{\"1\":{\"8\":1}}],[\"更指定該函數不受\",{\"1\":{\"30\":1}}],[\"更正確的認知\",{\"1\":{\"21\":1}}],[\"更接近於文本的複製貼上\",{\"1\":{\"5\":1}}],[\"建立對\",{\"1\":{\"21\":1}}],[\"認識好用的內建套件\",{\"1\":{\"21\":1}}],[\"另一方面也可以更加體會\",{\"1\":{\"21\":1}}],[\"另一個是指數函數\",{\"1\":{\"7\":1}}],[\"理解\",{\"1\":{\"21\":1}}],[\"結論\",{\"0\":{\"21\":1}}],[\"結構\",{\"1\":{\"8\":1}}],[\"即使中間出錯也會執行到底\",{\"1\":{\"20\":1}}],[\"資源\",{\"1\":{\"20\":1}}],[\"資源管理的深層應用\",{\"0\":{\"20\":1}}],[\"複數資源的調用過程相當於\",{\"1\":{\"19\":1}}],[\"複數資源管理\",{\"0\":{\"19\":1}}],[\"複習篇\",{\"1\":{\"6\":1}}],[\"若讀者有相關疑慮或者建議\",{\"1\":{\"32\":1}}],[\"若大家閒來無事的話可以參考看看\",{\"1\":{\"32\":1}}],[\"若有興趣的讀者可以到他們的官方網站一探究竟\",{\"1\":{\"32\":1}}],[\"若有興趣的讀者請參考\",{\"1\":{\"18\":1}}],[\"若要捕捉全部資料\",{\"1\":{\"18\":1}}],[\"將\",{\"1\":{\"31\":1}}],[\"將這些緊箍咒一一卸下後\",{\"1\":{\"31\":1}}],[\"將在\",{\"1\":{\"18\":1}}],[\"將編譯行為拆解成數個子區塊\",{\"1\":{\"6\":1}}],[\"到這邊我們就實現真正意義上的使用\",{\"1\":{\"31\":1}}],[\"到後面我們開始探討說\",{\"1\":{\"31\":1}}],[\"到目前為止的執行效能還可以透過平行化再上一層樓\",{\"1\":{\"30\":1}}],[\"到目前為止\",{\"1\":{\"26\":1,\"28\":1}}],[\"到目前為止是大家在學習\",{\"1\":{\"15\":1}}],[\"到檔案流\",{\"0\":{\"18\":1}}],[\"轉導引到其他檔案流\",{\"1\":{\"18\":1}}],[\"轉導\",{\"0\":{\"18\":1}}],[\"且每一個數值都是符點數\",{\"1\":{\"29\":1}}],[\"且在變數宣告過程中\",{\"1\":{\"25\":1}}],[\"且不只是更短的行數\",{\"1\":{\"16\":1}}],[\"且當檔案沒有真正開啟時不會列入計數\",{\"1\":{\"15\":1}}],[\"為套件發展基礎\",{\"1\":{\"32\":1}}],[\"為了方便進行不同工具間的比較\",{\"1\":{\"28\":1}}],[\"為主\",{\"1\":{\"24\":1}}],[\"為什麼使用\",{\"1\":{\"24\":1}}],[\"為什麼那麼慢\",{\"0\":{\"24\":1}}],[\"為例\",{\"1\":{\"16\":1}}],[\"為求簡便\",{\"1\":{\"7\":1}}],[\"使其能夠達到最佳效能\",{\"1\":{\"30\":1}}],[\"使用者需要透過語法\",{\"1\":{\"30\":1}}],[\"使用者往往不需要太多的功夫就能達成許多新鮮有趣的程式\",{\"1\":{\"24\":1}}],[\"使用\",{\"0\":{\"16\":1},\"1\":{\"27\":1,\"31\":2}}],[\"使得在檔案資源存取的時候結合計數器功能\",{\"1\":{\"15\":1}}],[\"使得我們可以實踐這個想法\",{\"1\":{\"8\":1}}],[\"現在我們要藉由\",{\"1\":{\"15\":1}}],[\"舉例來說\",{\"1\":{\"15\":1,\"20\":1,\"23\":1}}],[\"舉一個更實際的案例\",{\"0\":{\"7\":1}}],[\"方法可以幫助程序不中斷特定錯誤\",{\"1\":{\"20\":1}}],[\"方法可以幫助使用者強制執行子測試當中的所有測試\",{\"1\":{\"20\":1}}],[\"方法可以幫助使用者單元測試一程式碼片段是否會跳出預期錯誤\",{\"1\":{\"20\":1}}],[\"方法\",{\"1\":{\"15\":1}}],[\"方法就相當於呼叫\",{\"1\":{\"15\":1}}],[\"方法以釋放資源\",{\"1\":{\"15\":1}}],[\"方法以存取資源\",{\"1\":{\"15\":1}}],[\"本質上是一個\",{\"1\":{\"31\":1}}],[\"本來好端端能平行運算的東西\",{\"1\":{\"27\":1}}],[\"本身也有提供平行化的功能\",{\"1\":{\"30\":1}}],[\"本身的\",{\"1\":{\"15\":1}}],[\"本身\",{\"1\":{\"15\":1}}],[\"本篇我們將整理在\",{\"1\":{\"14\":1}}],[\"物件的\",{\"1\":{\"15\":1}}],[\"物件並觸發\",{\"1\":{\"15\":1}}],[\"區塊時\",{\"1\":{\"15\":1}}],[\"區塊前\",{\"1\":{\"15\":1}}],[\"接收到的字串流\",{\"1\":{\"18\":1}}],[\"接到的字串流當作資源\",{\"1\":{\"18\":1}}],[\"接下來我們將討論\",{\"1\":{\"15\":1}}],[\"接著我們就可以來看看在平行化加持下的效果如何\",{\"1\":{\"30\":1}}],[\"接著我們可以使用以下指令進行事先編譯\",{\"1\":{\"29\":1}}],[\"接著我們進一步探討\",{\"1\":{\"8\":1}}],[\"接著再將位元組碼提供給直譯器\",{\"1\":{\"26\":1}}],[\"接著另一個重點是\",{\"1\":{\"8\":1}}],[\"假設我們有一個檔案\",{\"1\":{\"15\":1}}],[\"單一檔案存取\",{\"0\":{\"15\":1}}],[\"單變數微分的連鎖律\",{\"1\":{\"7\":1}}],[\"透過\",{\"1\":{\"14\":1,\"15\":1,\"30\":1}}],[\"中也會遇到\",{\"1\":{\"31\":1}}],[\"中得到什麼好處\",{\"1\":{\"31\":1}}],[\"中級加速符文\",{\"0\":{\"30\":1}}],[\"中\",{\"1\":{\"27\":1}}],[\"中的許多場景\",{\"1\":{\"20\":1}}],[\"中的成員預設為\",{\"1\":{\"6\":2}}],[\"中面對資源存取問題時\",{\"1\":{\"14\":1}}],[\"釋放資源使用權\",{\"1\":{\"14\":1}}],[\"請求資源使用權\",{\"1\":{\"14\":1}}],[\"當然我們也可以依樣畫葫蘆\",{\"1\":{\"31\":1}}],[\"當程式執行到第二行時\",{\"1\":{\"27\":1}}],[\"當程式在調用資源的時候基本上包含兩個動作\",{\"1\":{\"14\":1}}],[\"當有些語法比較彆扭的時候可以包裝起來讓程式更美觀\",{\"1\":{\"17\":1}}],[\"當中也是相當知名的數學套件\",{\"1\":{\"31\":1}}],[\"當中的物件意涵\",{\"1\":{\"15\":1}}],[\"當中\",{\"1\":{\"6\":2}}],[\"遠端連線\",{\"1\":{\"14\":1}}],[\"一千維度到一萬維度\",{\"1\":{\"31\":1}}],[\"一萬點\",{\"1\":{\"31\":1}}],[\"一樣能達成類似的效果\",{\"1\":{\"30\":1}}],[\"一樣的測試場景\",{\"1\":{\"30\":1}}],[\"一個明顯的問題是他需要付上一定的成本去建置相關環境\",{\"1\":{\"31\":1}}],[\"一個大家常聽到的工具是\",{\"1\":{\"29\":1}}],[\"一個例子是\",{\"1\":{\"26\":1}}],[\"一個是二次多項式函數\",{\"1\":{\"7\":1}}],[\"一來他語法親民\",{\"1\":{\"24\":1}}],[\"一方面可以讓我們在之後使用\",{\"1\":{\"21\":1}}],[\"一般來說資源的來源可能是檔案\",{\"1\":{\"14\":1}}],[\"q\",{\"1\":{\"11\":1}}],[\"quality\",{\"1\":{\"4\":2}}],[\"++i\",{\"1\":{\"31\":1}}],[\"+=\",{\"1\":{\"11\":2,\"15\":2,\"16\":2,\"29\":1,\"30\":3,\"31\":2}}],[\"+\",{\"1\":{\"11\":4,\"29\":1,\"30\":4,\"31\":2}}],[\"zero\",{\"1\":{\"11\":1}}],[\"zip\",{\"1\":{\"11\":1}}],[\"z\",{\"1\":{\"11\":14}}],[\"手上可以有更多的工具或手法讓專案更簡潔或更強健\",{\"1\":{\"8\":1}}],[\"也非常歡迎在\",{\"1\":{\"32\":1}}],[\"也是在做類似的事情\",{\"1\":{\"31\":1}}],[\"也會根據當下取得的陣列資訊進行優化\",{\"1\":{\"30\":1}}],[\"也就是\",{\"1\":{\"26\":1}}],[\"也可以是一個抽象概念\",{\"1\":{\"20\":1}}],[\"也可以讓我們未來在實作\",{\"1\":{\"8\":1}}],[\"也有同樣的問題\",{\"1\":{\"18\":1}}],[\"也繼承自\",{\"1\":{\"8\":1}}],[\"免得說出現\",{\"1\":{\"8\":1}}],[\"替換失敗並非錯誤\",{\"1\":{\"8\":1}}],[\"替換成\",{\"1\":{\"6\":1}}],[\"`exc\",{\"1\":{\"15\":3}}],[\"`input\",{\"1\":{\"15\":1}}],[\"`\",{\"1\":{\"8\":4}}],[\"`double\",{\"1\":{\"8\":4}}],[\"抱持著這個想法\",{\"1\":{\"8\":1}}],[\"限制他是否擁有這個函數顯然更靠譜一些\",{\"1\":{\"8\":1}}],[\"比如程式碼中的\",{\"1\":{\"30\":1}}],[\"比如說\",{\"1\":{\"31\":1}}],[\"比如說以下程式碼\",{\"1\":{\"25\":1}}],[\"比如說一個程式執行的狀態\",{\"1\":{\"20\":1}}],[\"比如說一個檔案或是一個流\",{\"1\":{\"20\":1}}],[\"比如說你可以把\",{\"1\":{\"7\":1}}],[\"比如說李群對應到微分流形\",{\"1\":{\"7\":1}}],[\"比起限制類型的繼承關係\",{\"1\":{\"8\":1}}],[\"外\",{\"1\":{\"8\":1}}],[\"但使用這個方法也並非完全沒有缺點\",{\"1\":{\"31\":1}}],[\"但在計算部分我們另起爐灶\",{\"1\":{\"31\":1}}],[\"但我們觀察到\",{\"1\":{\"30\":1}}],[\"但又有些差異\",{\"1\":{\"29\":1}}],[\"但又不會讓程序中斷\",{\"1\":{\"20\":1}}],[\"但其實我們沒有那麼需要動態型別\",{\"1\":{\"29\":1}}],[\"但這邊還是得先打個預防針\",{\"1\":{\"28\":1}}],[\"但他仍然是一個非常有趣的套件\",{\"1\":{\"32\":1}}],[\"但他的計數器會加一\",{\"1\":{\"27\":1}}],[\"但他好慢\",{\"1\":{\"24\":1}}],[\"但僅限在多線程處理中才會遇到\",{\"1\":{\"27\":1}}],[\"但\",{\"1\":{\"26\":2,\"27\":1,\"30\":1}}],[\"但是\",{\"1\":{\"25\":1,\"26\":1}}],[\"但是這個招數不是萬能的\",{\"1\":{\"8\":1}}],[\"但也不代表說我們只能乾瞪眼任其一直慢下去\",{\"1\":{\"24\":1}}],[\"但也是存在一些李群內泛用的公式\",{\"1\":{\"7\":1}}],[\"但效能瓶頸卻發生在使用原生\",{\"1\":{\"23\":1}}],[\"但理解這個機制後\",{\"1\":{\"15\":1}}],[\"但還沒有檢查輸出格式\",{\"1\":{\"8\":1}}],[\"才能滿足我們剛剛給定的條件\",{\"1\":{\"8\":1}}],[\"^~~~~~~~~~~~~\",{\"1\":{\"8\":4}}],[\"^2\",{\"1\":{\"7\":2}}],[\"==\",{\"1\":{\"8\":2,\"11\":1,\"15\":1,\"16\":1,\"25\":2,\"27\":3}}],[\"=\",{\"1\":{\"8\":6,\"11\":19,\"15\":16,\"16\":4,\"17\":1,\"19\":2,\"25\":5,\"27\":3,\"28\":1,\"29\":1,\"30\":3,\"31\":4}}],[\"此時或許已經有一些讀者開始思考\",{\"1\":{\"30\":1}}],[\"此時會發現說我們不用自行宣告類別就可以實現同樣的功能\",{\"1\":{\"16\":1}}],[\"此時我們回過頭來提及上述所使用到的兩個工具\",{\"1\":{\"31\":1}}],[\"此時我們進一步探討\",{\"1\":{\"31\":1}}],[\"此時我們來看看\",{\"1\":{\"30\":1}}],[\"此時我們已經具備設計自定義資源管理器的基礎技能了\",{\"1\":{\"15\":1}}],[\"此時我們已經可以稍微感受到\",{\"1\":{\"6\":1}}],[\"此時我們就不需要局限於繼承的手法\",{\"1\":{\"8\":1}}],[\"此時編譯\",{\"1\":{\"8\":1}}],[\"因此以下筆者根據自己的使用經驗以及個人感受\",{\"1\":{\"32\":1}}],[\"因此在\",{\"1\":{\"31\":1}}],[\"因此他也比\",{\"1\":{\"30\":1}}],[\"因此不需要事先編譯\",{\"1\":{\"30\":1}}],[\"因此實質上它的內部數值還是被修改了\",{\"1\":{\"27\":1}}],[\"因此直譯器必須要逐步執行並逐步判斷接下來的運算行為\",{\"1\":{\"26\":1}}],[\"因此我們需要加上\",{\"1\":{\"30\":1}}],[\"因此我們需要再調整一下\",{\"1\":{\"8\":1}}],[\"因此我們並不會使用到動態型別的優勢\",{\"1\":{\"29\":1}}],[\"因此我們只要有\",{\"1\":{\"6\":1}}],[\"因為他在產品定位上更接近於一個\",{\"1\":{\"31\":1}}],[\"因為他本身已經是機械碼了\",{\"1\":{\"29\":1}}],[\"因為記憶體管理的因素\",{\"1\":{\"27\":1}}],[\"因為編譯型語言在執行階段就是讀機械碼\",{\"1\":{\"26\":1}}],[\"因為我們還沒有修改\",{\"1\":{\"8\":1}}],[\"做檢查\",{\"1\":{\"8\":1}}],[\"有沒有稍微簡單一點的平行化方法呢\",{\"1\":{\"30\":1}}],[\"有全域直譯器鎖\",{\"0\":{\"27\":1}}],[\"有繼承\",{\"1\":{\"8\":1}}],[\"有這些先備知識後我們就可以來實作了\",{\"1\":{\"7\":1}}],[\"上\",{\"1\":{\"8\":1}}],[\"上述我們的例子並沒有做到這件事情\",{\"1\":{\"6\":1}}],[\"標頭裡面提供的\",{\"1\":{\"8\":1}}],[\"幫了我們一把\",{\"1\":{\"8\":1}}],[\"正常的物件導向裡面並沒有模板的概念\",{\"1\":{\"8\":1}}],[\"傳統\",{\"1\":{\"8\":1}}],[\"從一開始介紹動態型別\",{\"1\":{\"31\":1}}],[\"從傳統物件導向的角度來說\",{\"1\":{\"8\":1}}],[\"從編譯器的角度也是\",{\"1\":{\"6\":1}}],[\"引進了\",{\"1\":{\"8\":1}}],[\"如此才能將加速機制發揮到極致\",{\"1\":{\"29\":1}}],[\"如此乍看之下\",{\"1\":{\"25\":1}}],[\"如空裝置或標準錯誤流\",{\"1\":{\"18\":1}}],[\"如何限制型態結構\",{\"1\":{\"8\":1}}],[\"如果用\",{\"1\":{\"28\":1}}],[\"如果\",{\"1\":{\"6\":1}}],[\"如果是\",{\"1\":{\"5\":1}}],[\"裡面也有一些本文未提及的暗黑兵法\",{\"1\":{\"32\":1}}],[\"裡面\",{\"1\":{\"7\":1}}],[\"裡面的函數當中\",{\"1\":{\"6\":1}}],[\"裡面的實作細節\",{\"1\":{\"6\":1}}],[\"裡面的餡料我們晚點再一個個型態各自定義\",{\"1\":{\"6\":1}}],[\"並沒有得到所謂\",{\"1\":{\"32\":1}}],[\"並比較各方法之間的效能差異\",{\"1\":{\"31\":1}}],[\"並以此作為垃圾回收機制以及記憶體管理的基礎\",{\"1\":{\"27\":1}}],[\"並於執行階段再將其交由\",{\"1\":{\"26\":1}}],[\"並試圖使用一些現有工具去達成運算加速的目的\",{\"1\":{\"23\":1}}],[\"並無法捕捉所有\",{\"1\":{\"18\":1}}],[\"並且在這個實作中\",{\"1\":{\"30\":1}}],[\"並且將程式碼事先編譯\",{\"1\":{\"29\":1}}],[\"並且將其回傳值賦予到\",{\"1\":{\"15\":1}}],[\"並且該計數器為\",{\"1\":{\"27\":1}}],[\"並且方便\",{\"1\":{\"25\":1}}],[\"並且很簡易地在主函數中直接呼叫\",{\"1\":{\"6\":1}}],[\"並不是只有一個實作方法可以實現上述案例\",{\"1\":{\"7\":1}}],[\"筆者認為他比較難上手\",{\"1\":{\"29\":1}}],[\"筆者在這邊澄清一點是\",{\"1\":{\"7\":1}}],[\"筆者當初是在閱讀\",{\"1\":{\"7\":1}}],[\"應該是正確的\",{\"1\":{\"7\":1}}],[\"讀者可以快速驗算一下\",{\"1\":{\"7\":1}}],[\"輸出如下\",{\"1\":{\"7\":1}}],[\"內部並沒有任何函數\",{\"1\":{\"7\":1}}],[\"會被初始化\",{\"1\":{\"27\":1}}],[\"會觸發\",{\"1\":{\"15\":1}}],[\"會初始化\",{\"1\":{\"15\":1}}],[\"會噴以下錯誤訊息\",{\"1\":{\"8\":1}}],[\"會變成是一個還不錯的選擇\",{\"1\":{\"7\":1}}],[\"會變成是空的類別\",{\"1\":{\"7\":1}}],[\"會根據他接收到的型態\",{\"1\":{\"6\":1}}],[\"兩個類別\",{\"1\":{\"7\":1}}],[\"x86\",{\"1\":{\"29\":2}}],[\"xxx\",{\"1\":{\"29\":2}}],[\"xxm\",{\"1\":{\"29\":1}}],[\"xx\",{\"1\":{\"8\":1}}],[\"xx>\",{\"1\":{\"8\":1}}],[\"x^2\",{\"1\":{\"7\":2}}],[\"x=0\",{\"1\":{\"7\":4}}],[\"x\",{\"1\":{\"7\":16,\"8\":17,\"11\":8,\"31\":4}}],[\"xd\",{\"1\":{\"6\":1}}],[\"微分的意思\",{\"1\":{\"7\":1}}],[\"代表的是對\",{\"1\":{\"7\":1}}],[\"滿足以下定律\",{\"1\":{\"7\":1}}],[\"避免可能有讀者不太清楚微積分\",{\"1\":{\"7\":1}}],[\"數學方面的那種\",{\"1\":{\"7\":1}}],[\"之微積分行為這類的\",{\"1\":{\"7\":1}}],[\"之間的映射關係\",{\"1\":{\"7\":1}}],[\"或者本篇留言中回覆\",{\"1\":{\"32\":1}}],[\"或者需要進行叢集運算為佳\",{\"1\":{\"32\":1}}],[\"或者單純想炫技\",{\"1\":{\"32\":1}}],[\"或者想要追求極致效能\",{\"1\":{\"32\":1}}],[\"或者是\",{\"1\":{\"30\":1}}],[\"或者說數值計算\",{\"1\":{\"28\":1}}],[\"或者直接將這個結構理解成\",{\"1\":{\"20\":1}}],[\"或是某種\",{\"1\":{\"14\":1}}],[\"或是相似的架構\",{\"1\":{\"5\":1}}],[\"或\",{\"1\":{\"8\":1,\"25\":1}}],[\"或特殊歐基里德群\",{\"1\":{\"7\":1}}],[\"與原生\",{\"1\":{\"31\":1}}],[\"與編譯型\",{\"1\":{\"26\":1}}],[\"與\",{\"1\":{\"7\":1,\"8\":1,\"30\":1,\"31\":1}}],[\"與特定情況\",{\"1\":{\"6\":1}}],[\"以\",{\"1\":{\"32\":1}}],[\"以達到最佳的效能\",{\"1\":{\"31\":1}}],[\"以外的套件功能\",{\"1\":{\"31\":1}}],[\"以避免不良的平行化機制\",{\"1\":{\"30\":1}}],[\"以下會用比較簡易的方式進行探討\",{\"1\":{\"24\":1}}],[\"以下我們透過一些案例來介紹\",{\"1\":{\"16\":1}}],[\"以方便且快速地實現矩陣運算\",{\"1\":{\"23\":1}}],[\"以及額外功能\",{\"1\":{\"16\":1}}],[\"以及內建套件\",{\"1\":{\"14\":1}}],[\"以及\",{\"1\":{\"14\":1,\"31\":1}}],[\"以及簡潔程度\",{\"1\":{\"5\":1}}],[\"以檔案來說就是讀或寫之類的\",{\"1\":{\"14\":1}}],[\"以前我們熟知的是\",{\"1\":{\"8\":1}}],[\"以我們的例子來說\",{\"1\":{\"8\":1}}],[\"以至於這篇文章用某種角度來看就是\",{\"1\":{\"6\":1}}],[\"黏貼\",{\"1\":{\"6\":1}}],[\"嚴格來講\",{\"1\":{\"6\":1}}],[\"記憶體\",{\"1\":{\"6\":1}}],[\"我不知道他在寫什麼鬼東西哭阿\",{\"1\":{\"8\":1}}],[\"我不需要改一個小區塊\",{\"1\":{\"6\":1}}],[\"我們看到\",{\"1\":{\"31\":1}}],[\"我們對原始碼進行編譯\",{\"1\":{\"31\":1}}],[\"我們對於\",{\"1\":{\"26\":1}}],[\"我們不妨自己寫\",{\"1\":{\"31\":1}}],[\"我們不需要為變數指定他的型態\",{\"1\":{\"25\":1}}],[\"我們真的有那麼需要\",{\"1\":{\"31\":1}}],[\"我們也獲得了飛躍的效能提升\",{\"1\":{\"31\":1}}],[\"我們需要動態型別嗎\",{\"1\":{\"31\":1}}],[\"我們並沒有將\",{\"1\":{\"30\":1}}],[\"我們發現他與\",{\"1\":{\"30\":1}}],[\"我們發現在平行化加持下\",{\"1\":{\"30\":1}}],[\"我們直接上程式碼\",{\"1\":{\"30\":1}}],[\"我們在固定點數量\",{\"1\":{\"31\":1}}],[\"我們在固定數值點的維度\",{\"1\":{\"29\":1}}],[\"我們在上層呼叫中仍然使用\",{\"1\":{\"31\":1}}],[\"我們在上述計算成本大的運算中\",{\"1\":{\"31\":1}}],[\"我們在此介紹另外一個強大的工具\",{\"1\":{\"30\":1}}],[\"我們已經逐漸逼近\",{\"1\":{\"30\":1}}],[\"我們已經可以看到\",{\"1\":{\"6\":1}}],[\"我們就可以來一窺這個加速符文的功效了\",{\"1\":{\"29\":1}}],[\"我們留意到他只能由指定的\",{\"1\":{\"29\":1}}],[\"我們很明確地知道輸入的數列是一個二維向量\",{\"1\":{\"29\":1}}],[\"我們想要計算出這個數列所形成的弧長\",{\"1\":{\"28\":1}}],[\"我們使用\",{\"1\":{\"31\":2}}],[\"我們使用相同的數值計算問題\",{\"1\":{\"28\":1}}],[\"我們使用了\",{\"1\":{\"6\":2}}],[\"我們著重於科學計算\",{\"1\":{\"28\":1}}],[\"我們大致理解\",{\"1\":{\"28\":1}}],[\"我們用以下例子說明\",{\"1\":{\"27\":1}}],[\"我們都沒有提示說該變數的型態為何\",{\"1\":{\"25\":1}}],[\"我們將探討\",{\"1\":{\"23\":1}}],[\"我們利用裝飾器\",{\"1\":{\"30\":1}}],[\"我們利用\",{\"1\":{\"23\":1}}],[\"我們習於使用\",{\"1\":{\"23\":1}}],[\"我們以\",{\"1\":{\"16\":1}}],[\"我們會發現計數器有成功的被運作\",{\"1\":{\"15\":1}}],[\"我們會發現\",{\"1\":{\"15\":1}}],[\"我們同樣盯著上面的範例程式碼看\",{\"1\":{\"15\":1}}],[\"我們換個做法\",{\"1\":{\"8\":1}}],[\"我們可以看到\",{\"1\":{\"31\":1}}],[\"我們可以使用以下程式碼\",{\"1\":{\"28\":1}}],[\"我們可以事先將軌道鋪得遠一些\",{\"1\":{\"26\":1}}],[\"我們可以自定義一種類別\",{\"1\":{\"15\":1}}],[\"我們可以結合\",{\"1\":{\"15\":1}}],[\"我們可以透過以下程式碼實現讀檔並輸出到終端機上\",{\"1\":{\"15\":1}}],[\"我們可以透過多型去選擇參數的可輸入型態\",{\"1\":{\"8\":1}}],[\"我們可以進一步將主函數當中的行為包裝成一個\",{\"1\":{\"6\":1}}],[\"我們可以進一步允許當使用者輸入不同的類別時\",{\"1\":{\"5\":1}}],[\"我們預計來實作兩個簡單的函數\",{\"1\":{\"7\":1}}],[\"我們舉一個比較通俗的案例\",{\"1\":{\"7\":1}}],[\"我們把\",{\"1\":{\"6\":1}}],[\"我們把程式碼拆解成三個檔案\",{\"1\":{\"6\":1}}],[\"我們才能透過\",{\"1\":{\"6\":1}}],[\"我們再把\",{\"1\":{\"6\":1}}],[\"我們稱之為\",{\"1\":{\"5\":1}}],[\"我們先看最簡單的案例\",{\"1\":{\"5\":1}}],[\"縮短編譯時間\",{\"1\":{\"6\":1}}],[\"抓住這個想法\",{\"1\":{\"6\":1}}],[\"要抓\",{\"1\":{\"6\":1}}],[\"你可以看到我們並沒有使用到其他特殊的語句\",{\"1\":{\"29\":1}}],[\"你可能不知道的是\",{\"1\":{\"6\":1}}],[\"你就必須得這麼做\",{\"1\":{\"25\":1}}],[\"你總不能叫\",{\"1\":{\"8\":1}}],[\"你再告訴他定義就好了\",{\"1\":{\"6\":1}}],[\"你只需要在\",{\"1\":{\"6\":1}}],[\"意思是說直譯器需要確保變數在每個時刻下只被一個線程控制\",{\"1\":{\"27\":1}}],[\"意思是說\",{\"1\":{\"6\":1,\"20\":1,\"30\":1}}],[\"其物件意涵\",{\"1\":{\"14\":1}}],[\"其中我們在第十七行使用\",{\"1\":{\"30\":1}}],[\"其中我們將數列表達成一個二維陣列\",{\"1\":{\"28\":1}}],[\"其中每一列代表數列中的一個點\",{\"1\":{\"28\":1}}],[\"其中\",{\"1\":{\"8\":1,\"30\":1}}],[\"其中那個\",{\"1\":{\"7\":1}}],[\"其中在\",{\"1\":{\"6\":1}}],[\"其實\",{\"1\":{\"31\":1}}],[\"其實他們已經默默幫我們做到這件事情了\",{\"1\":{\"31\":1}}],[\"其實這個版本跟原始\",{\"1\":{\"28\":1}}],[\"其實就是我把\",{\"1\":{\"6\":1}}],[\"其實只要知道有\",{\"1\":{\"6\":1}}],[\"其他的則是會把含有\",{\"1\":{\"6\":1}}],[\"實作這個功能的話\",{\"1\":{\"28\":1}}],[\"實作案例\",{\"0\":{\"6\":1}}],[\"實務上他可以幫助\",{\"1\":{\"16\":1}}],[\"實際上\",{\"1\":{\"32\":1}}],[\"實際上也有其他套件能做到類似的事情\",{\"1\":{\"29\":1}}],[\"實際上他相當於以下語法結構\",{\"1\":{\"15\":1}}],[\"實際上更多的使用情境是\",{\"1\":{\"6\":1}}],[\"玩深一點\",{\"1\":{\"6\":1}}],[\"是對於\",{\"1\":{\"30\":1}}],[\"是一個動態型別語言\",{\"1\":{\"29\":1}}],[\"是直譯型語言\",{\"0\":{\"26\":1}}],[\"是否繼承\",{\"1\":{\"8\":1}}],[\"是\",{\"1\":{\"6\":1,\"8\":1}}],[\"按照這個例子的話\",{\"1\":{\"6\":1}}],[\"去實現高性能的科學計算功能\",{\"1\":{\"31\":1}}],[\"去實現這個想法\",{\"1\":{\"5\":1}}],[\"去轉換成機械碼\",{\"1\":{\"26\":1}}],[\"去做更彈性的編排\",{\"1\":{\"15\":1}}],[\"去判斷型態是否有指定的靜態函數\",{\"1\":{\"8\":1}}],[\"去決定要實際向誰取得實作內容\",{\"1\":{\"6\":1}}],[\"差異是\",{\"1\":{\"6\":1}}],[\"在表格中我們還另外將\",{\"1\":{\"32\":1}}],[\"在一萬維度的情況下\",{\"1\":{\"31\":1}}],[\"在一千萬個點的案例中\",{\"1\":{\"30\":1}}],[\"在不使用\",{\"1\":{\"31\":1}}],[\"在不同版本可能會有不同的\",{\"1\":{\"31\":1}}],[\"在不需要知道實際結構\",{\"1\":{\"6\":1}}],[\"在內部參照了\",{\"1\":{\"31\":1}}],[\"在沒有詳細閱讀文件的前提下直接撰寫也有一定的風險\",{\"1\":{\"31\":1}}],[\"在科學計算中\",{\"1\":{\"31\":1}}],[\"在以上實作中\",{\"1\":{\"30\":1}}],[\"在以上程式碼中\",{\"1\":{\"30\":1}}],[\"在六核十二執行緒的執行環境下\",{\"1\":{\"30\":1}}],[\"在上述的效能比較中\",{\"1\":{\"30\":1}}],[\"在上述測試中\",{\"1\":{\"30\":1}}],[\"在上文中\",{\"1\":{\"29\":1}}],[\"在上面的案例中的資源都是十分具體的\",{\"1\":{\"20\":1}}],[\"在實際測試中我們試驗一百萬到一千萬個點\",{\"1\":{\"29\":1}}],[\"在筆者使用的電腦中\",{\"1\":{\"29\":1}}],[\"在程式碼中\",{\"1\":{\"27\":1}}],[\"在已知型態的前提下\",{\"1\":{\"26\":1}}],[\"在靜態型別\",{\"1\":{\"25\":1}}],[\"在第一行時\",{\"1\":{\"25\":1}}],[\"在本文中我們以\",{\"1\":{\"24\":1}}],[\"在本文中\",{\"1\":{\"23\":1,\"28\":1}}],[\"在本篇我們大致了解\",{\"1\":{\"8\":1}}],[\"在處理資源管理的時候可以更加優雅\",{\"1\":{\"16\":1}}],[\"在執行階段中\",{\"1\":{\"26\":1}}],[\"在執行結果中\",{\"1\":{\"15\":1}}],[\"在執行程式的時候通常會需要存取資源\",{\"1\":{\"14\":1}}],[\"在檔案的例子中\",{\"1\":{\"15\":1}}],[\"在進入\",{\"1\":{\"15\":1}}],[\"在這之中我們發現在適當的程式編排下\",{\"1\":{\"29\":1}}],[\"在這邊我們使用\",{\"1\":{\"31\":1}}],[\"在這邊我們需要為本來的程式碼加上\",{\"1\":{\"30\":1}}],[\"在這邊我們首先介紹第一個工具\",{\"1\":{\"29\":1}}],[\"在這邊可以看到我們透過註解\",{\"1\":{\"29\":1}}],[\"在這段程式碼中\",{\"1\":{\"15\":1}}],[\"在這個案例中\",{\"1\":{\"31\":1}}],[\"在這個範例中\",{\"1\":{\"31\":2}}],[\"在這個比較當中\",{\"1\":{\"30\":1}}],[\"在這個地方是作為累加的單一變數\",{\"1\":{\"30\":1}}],[\"在這個測試當中\",{\"1\":{\"29\":1}}],[\"在這個實作方式下\",{\"1\":{\"7\":1}}],[\"在這個例子裡\",{\"1\":{\"6\":1}}],[\"在這個例子中\",{\"1\":{\"6\":1}}],[\"在這個例子當中\",{\"1\":{\"5\":1}}],[\"在這種情境底下套用\",{\"1\":{\"7\":1}}],[\"在這份實作當中他們的應用情境是在不同李群當中\",{\"1\":{\"7\":1}}],[\"在\",{\"1\":{\"6\":3,\"15\":1,\"16\":1,\"23\":1,\"27\":1,\"30\":1}}],[\"型態檢查\",{\"0\":{\"8\":1}}],[\"型態\",{\"1\":{\"6\":1}}],[\"非\",{\"1\":{\"6\":1}}],[\"宣告並定義在一般情況\",{\"1\":{\"6\":1}}],[\"先來看一個例子\",{\"1\":{\"6\":1}}],[\"他是一種\",{\"1\":{\"32\":1}}],[\"他在使用定位上比較接近叢集運算\",{\"1\":{\"32\":1}}],[\"他在\",{\"1\":{\"31\":1}}],[\"他提供了相對\",{\"1\":{\"31\":1}}],[\"他提供了為函數參數提供指定型態的功能\",{\"1\":{\"29\":1}}],[\"他真正在做的事情是將\",{\"1\":{\"31\":1}}],[\"他能夠允許使用者在不涉及到這麼多細節的前提下\",{\"1\":{\"30\":1}}],[\"他們在使用上還是受到套件本身的限制\",{\"1\":{\"31\":1}}],[\"他們在計算上都是只有使用到單一線程\",{\"1\":{\"30\":1}}],[\"他們會自動判斷程式碼並套用合適的平行化機制\",{\"1\":{\"30\":1}}],[\"他們對應的函數\",{\"1\":{\"7\":1}}],[\"他有點像\",{\"1\":{\"29\":1}}],[\"他有一個關鍵字就直接叫做\",{\"1\":{\"5\":1}}],[\"他強制了該模板的型態必須具備相同的繼承關係\",{\"1\":{\"8\":1}}],[\"他只是型態不是類別\",{\"1\":{\"8\":1}}],[\"他的做法就是引進全域直譯器鎖\",{\"1\":{\"27\":1}}],[\"他的編譯過程也是將原始碼轉成位元組碼\",{\"1\":{\"26\":1}}],[\"他的行為是在執行期間\",{\"1\":{\"8\":1}}],[\"他的合法使用時機在於編譯器是否需要知道他的實際結構\",{\"1\":{\"6\":1}}],[\"他會在同一層目錄下建立一個名稱類似於\",{\"1\":{\"29\":1}}],[\"他會告訴我們\",{\"1\":{\"8\":1}}],[\"他會把含有\",{\"1\":{\"6\":1}}],[\"他會貼上個別對應的實作方法\",{\"1\":{\"5\":1}}],[\"他依靠了\",{\"1\":{\"5\":1}}],[\"具備更多類別之間的相互關係\",{\"1\":{\"5\":1}}],[\"而是說我們需要根據當下的實作情境去選擇最適合的工具\",{\"1\":{\"32\":1}}],[\"而言更上層的語法介面\",{\"1\":{\"31\":1}}],[\"而相似的困境在\",{\"1\":{\"31\":1}}],[\"而到目前為止的試驗中我們也發現\",{\"1\":{\"31\":1}}],[\"而由於\",{\"1\":{\"30\":1}}],[\"而被迫降級成實質單線程運算的品質\",{\"1\":{\"27\":1}}],[\"而動態型別的不可預期性讓效能在執行階段難以被優化\",{\"1\":{\"26\":1}}],[\"而在第二行時\",{\"1\":{\"25\":1}}],[\"而在抽象層面上我們也不是很介意各自實作細節\",{\"1\":{\"6\":1}}],[\"而當程序離開\",{\"1\":{\"15\":1}}],[\"而透過上述程式碼所形成的結構我們都可以稱作資源管理\",{\"1\":{\"20\":1}}],[\"而透過\",{\"1\":{\"15\":1}}],[\"而且可以執行更精準的判斷\",{\"1\":{\"8\":1}}],[\"而不是強制他必須具備某種\",{\"1\":{\"8\":1}}],[\"而我們希望輸入進來的型態\",{\"1\":{\"8\":1}}],[\"而我們希望透過一些機制\",{\"1\":{\"5\":1}}],[\"而檢查的結果會回饋在\",{\"1\":{\"8\":1}}],[\"而只取其指標來用的前提下\",{\"1\":{\"6\":1}}],[\"而\",{\"1\":{\"6\":1,\"8\":1,\"15\":1,\"31\":1}}],[\"而仰賴模板偏特化\",{\"1\":{\"5\":1}}],[\"而繼承則是一個物件導向的概念\",{\"1\":{\"5\":1}}],[\"只能讓火車走一步停一步\",{\"1\":{\"26\":1}}],[\"只是這個過程是編譯器幫你完成的\",{\"1\":{\"5\":1}}],[\"只要在其中定義想要打包的程式碼\",{\"1\":{\"5\":1}}],[\"繼承\",{\"1\":{\"5\":1}}],[\"跟\",{\"1\":{\"5\":1,\"6\":2,\"7\":1,\"8\":2,\"31\":1}}],[\"不同的是\",{\"1\":{\"30\":1}}],[\"不同的李群包含旋轉群\",{\"1\":{\"7\":1}}],[\"不管是\",{\"1\":{\"30\":1}}],[\"不須多加編譯或解析\",{\"1\":{\"26\":1}}],[\"不要重造輪子\",{\"1\":{\"19\":1}}],[\"不希望破壞類別內部方法結構時\",{\"1\":{\"7\":1}}],[\"不盡相同\",{\"1\":{\"7\":1}}],[\"不過我們沒有將\",{\"1\":{\"32\":1}}],[\"不過我們切換另一個實驗場景\",{\"1\":{\"31\":1}}],[\"不過我們需要分一點層次去探討他慢的理由\",{\"1\":{\"24\":1}}],[\"不過不可諱言地說\",{\"1\":{\"31\":1}}],[\"不過取而代之\",{\"1\":{\"30\":1}}],[\"不過使用者需要熟悉\",{\"1\":{\"29\":1}}],[\"不過以下會告訴大家\",{\"1\":{\"28\":1}}],[\"不過\",{\"1\":{\"8\":1,\"31\":1}}],[\"不過當你基於某些理由\",{\"1\":{\"7\":1}}],[\"不過這個案例有點太超過了\",{\"1\":{\"7\":1}}],[\"不過實際操作上更多的是活用\",{\"1\":{\"6\":1}}],[\"不過想得單純一點\",{\"1\":{\"6\":1}}],[\"不過你會發現他就真的只是複製貼上而已\",{\"1\":{\"5\":1}}],[\"不見得每個型態都有相同的行為\",{\"1\":{\"6\":1}}],[\"不專業使用心得\",{\"0\":{\"5\":1}}],[\"就是一個重要的資訊\",{\"1\":{\"30\":1}}],[\"就是這樣\",{\"1\":{\"27\":1}}],[\"就足以讓編譯器決定說如何能讓程式效率變得更好\",{\"1\":{\"29\":1}}],[\"就弧長計算的例子來說\",{\"1\":{\"29\":1}}],[\"就好比程式執行的過程像是火車在前進\",{\"1\":{\"26\":1}}],[\"就算是\",{\"1\":{\"18\":1}}],[\"就這個角度來說\",{\"1\":{\"8\":1}}],[\"就這方面來講\",{\"1\":{\"5\":1}}],[\"就把全部的程式碼都重新編譯\",{\"1\":{\"6\":1}}],[\"就只剩下宣告而已\",{\"1\":{\"6\":1}}],[\"就可以再利用\",{\"1\":{\"5\":1}}],[\"這部分就有一點點偏離本篇的主題了\",{\"1\":{\"32\":1}}],[\"這些套件他們各自都有自己最關心的議題\",{\"1\":{\"32\":1}}],[\"這邊我們介紹\",{\"1\":{\"31\":1}}],[\"這邊又定義了一個基底類別\",{\"1\":{\"8\":1}}],[\"這導致我們在實作上會有一點麻煩\",{\"1\":{\"31\":1}}],[\"這句話的意思是說\",{\"1\":{\"31\":1}}],[\"這還差得遠\",{\"1\":{\"28\":1}}],[\"這也是\",{\"1\":{\"27\":1}}],[\"這意味著新增或者減少參考計數\",{\"1\":{\"27\":1}}],[\"這使得說每個變數的計數器在多線程處理中需要被保護\",{\"1\":{\"27\":1}}],[\"這次我們利用了\",{\"1\":{\"8\":1}}],[\"這樣乍看下來\",{\"1\":{\"26\":1}}],[\"這樣的想法實際上也被應用在\",{\"1\":{\"20\":1}}],[\"這樣\",{\"1\":{\"6\":1}}],[\"這個方案\",{\"1\":{\"31\":1}}],[\"這個\",{\"1\":{\"30\":1}}],[\"這個說法本身並沒有錯\",{\"1\":{\"26\":1}}],[\"這個便利性是有代價的\",{\"1\":{\"25\":1}}],[\"這個強大內建套件就是\",{\"1\":{\"16\":1}}],[\"這個特性使得模板中的型態\",{\"1\":{\"8\":1}}],[\"這個基本上就是\",{\"1\":{\"6\":1}}],[\"這個時候\",{\"1\":{\"6\":1}}],[\"這個例子的輸出結果是滿直覺的\",{\"1\":{\"6\":1}}],[\"這個概念若使用得當\",{\"1\":{\"5\":1}}],[\"這兩個方法\",{\"1\":{\"5\":1}}],[\"都同時擁有\",{\"1\":{\"5\":1}}],[\"和\",{\"1\":{\"5\":2,\"7\":5}}],[\">>\",{\"1\":{\"31\":1}}],[\">\",{\"1\":{\"5\":1,\"28\":1,\"29\":1,\"30\":1}}],[\"<omp\",{\"1\":{\"31\":1}}],[\"<pybind11\",{\"1\":{\"31\":3}}],[\"<typename\",{\"1\":{\"8\":6}}],[\"<type\",{\"1\":{\"8\":3}}],[\"<cmath>\",{\"1\":{\"7\":1,\"8\":1}}],[\"<<\",{\"1\":{\"6\":12,\"7\":6}}],[\"<iostream>\",{\"1\":{\"6\":4,\"7\":1}}],[\"<\",{\"1\":{\"5\":1,\"31\":1}}],[\"貼到\",{\"1\":{\"6\":1}}],[\"貼到任何類別\",{\"1\":{\"5\":1}}],[\"貼到某塊程式碼內\",{\"1\":{\"5\":1}}],[\"把他當作補丁一般地\",{\"1\":{\"5\":1}}],[\"簡單來講就是一個程式碼片段\",{\"1\":{\"5\":1}}],[\"的結論\",{\"1\":{\"32\":1}}],[\"的潛力\",{\"1\":{\"31\":1}}],[\"的前提下\",{\"1\":{\"31\":1}}],[\"的情況下\",{\"1\":{\"31\":1}}],[\"的線性代數運算\",{\"1\":{\"31\":1}}],[\"的文章\",{\"1\":{\"31\":1}}],[\"的使用注意事項以及心得也可以參考\",{\"1\":{\"31\":1}}],[\"的使用概念\",{\"1\":{\"5\":1}}],[\"的轉換器\",{\"1\":{\"31\":1}}],[\"的設計機制導致我們用了不合理的運算時間才能得到計算結果\",{\"1\":{\"31\":1}}],[\"的效果如何\",{\"1\":{\"30\":1}}],[\"的效能納入比較對象\",{\"1\":{\"32\":1}}],[\"的效能比\",{\"1\":{\"29\":1}}],[\"的效能問題有以下簡單的見解\",{\"1\":{\"26\":1}}],[\"的效能問題則有不同的處理手段\",{\"1\":{\"24\":1}}],[\"的介入\",{\"1\":{\"30\":1}}],[\"的運算極限了\",{\"1\":{\"30\":1}}],[\"的語法註解\",{\"1\":{\"30\":1}}],[\"的初步實作\",{\"1\":{\"30\":1}}],[\"的加速\",{\"1\":{\"28\":1}}],[\"的加持下它可以被簡化成以下形式\",{\"1\":{\"16\":1}}],[\"的方式管理記憶體\",{\"1\":{\"27\":1}}],[\"的型態變成字串\",{\"1\":{\"25\":1}}],[\"的型態為整數\",{\"1\":{\"25\":1}}],[\"的理由很簡單\",{\"1\":{\"24\":1}}],[\"的一些機制\",{\"1\":{\"21\":1}}],[\"的一些使用方法\",{\"1\":{\"16\":1}}],[\"的一些使用時機\",{\"1\":{\"14\":1}}],[\"的時候可以更有自信\",{\"1\":{\"21\":1}}],[\"的時候幾乎會碰觸到的課題\",{\"1\":{\"15\":1}}],[\"的資源管理後\",{\"1\":{\"21\":1}}],[\"的操作過程\",{\"1\":{\"19\":1}}],[\"的回傳值實際上就是物件\",{\"1\":{\"15\":1}}],[\"的常見作法\",{\"1\":{\"14\":1}}],[\"的這種窘境之外\",{\"1\":{\"8\":1}}],[\"的想法以及實現方式\",{\"1\":{\"8\":1}}],[\"的關鍵特性是他會在編譯期間\",{\"1\":{\"8\":1}}],[\"的意思是說\",{\"1\":{\"8\":1,\"25\":1}}],[\"的概念\",{\"1\":{\"8\":1}}],[\"的概念就還滿方便的\",{\"1\":{\"7\":1}}],[\"的主要想法\",{\"1\":{\"6\":1}}],[\"的味道\",{\"1\":{\"6\":1}}],[\"的最大幫助在於可以降低程式碼之間的耦合程度\",{\"1\":{\"6\":1}}],[\"的實際行為時\",{\"1\":{\"6\":1}}],[\"的存在就可以寫程式了\",{\"1\":{\"6\":1}}],[\"的另外一個來使用\",{\"1\":{\"6\":1}}],[\"的那個函數拿來使用\",{\"1\":{\"6\":1}}],[\"的\",{\"1\":{\"6\":2,\"18\":1,\"29\":1,\"30\":1,\"32\":1}}],[\"的其他所有型態\",{\"1\":{\"6\":1}}],[\"的特性\",{\"1\":{\"5\":1,\"6\":1}}],[\"的話\",{\"1\":{\"5\":1}}],[\"的過程中發現了\",{\"1\":{\"5\":1}}],[\"近期在閱讀一些\",{\"1\":{\"5\":1}}],[\"955154109e\",{\"1\":{\"11\":1}}],[\"9e\",{\"1\":{\"11\":8}}],[\"9\",{\"1\":{\"8\":1,\"11\":6}}],[\"984738046e\",{\"1\":{\"11\":1}}],[\"98\",{\"1\":{\"4\":1}}],[\"97\",{\"1\":{\"2\":1}}],[\"yield\",{\"1\":{\"16\":1,\"17\":1}}],[\"you\",{\"1\":{\"15\":1,\"16\":1,\"25\":1}}],[\"yalmip\",{\"1\":{\"13\":1}}],[\"y\",{\"1\":{\"11\":5}}],[\"years\",{\"1\":{\"4\":1}}],[\"yu\",{\"1\":{\"1\":1,\"2\":1,\"3\":2,\"4\":1}}],[\"850239930e+00\",{\"1\":{\"11\":1}}],[\"81e\",{\"1\":{\"11\":1}}],[\"819535948e\",{\"1\":{\"11\":1}}],[\"849970349e\",{\"1\":{\"11\":1}}],[\"8e\",{\"1\":{\"11\":7}}],[\"8\",{\"1\":{\"11\":9}}],[\"87\",{\"1\":{\"4\":1}}],[\"88\",{\"1\":{\"3\":1}}],[\"80\",{\"1\":{\"3\":1}}],[\"gil\",{\"1\":{\"31\":1}}],[\"given\",{\"1\":{\"3\":1}}],[\"gnu\",{\"1\":{\"29\":1}}],[\"gnss+\",{\"1\":{\"4\":1}}],[\"gnss\",{\"0\":{\"4\":1},\"1\":{\"4\":12}}],[\"gc\",{\"1\":{\"27\":4}}],[\"go\",{\"1\":{\"15\":1}}],[\"gfeas\",{\"1\":{\"11\":2}}],[\"gpus\",{\"1\":{\"33\":1}}],[\"gpu\",{\"1\":{\"30\":1,\"32\":1}}],[\"gp\",{\"1\":{\"11\":2}}],[\"g++\",{\"1\":{\"8\":1}}],[\"g\",{\"1\":{\"8\":10,\"12\":1,\"31\":1}}],[\"g>\",{\"1\":{\"7\":1,\"8\":5}}],[\"gtsam\",{\"1\":{\"7\":1}}],[\"get\",{\"1\":{\"11\":1,\"17\":2,\"27\":3}}],[\"getreturndescription\",{\"1\":{\"5\":2}}],[\"getreturntype\",{\"1\":{\"5\":2}}],[\"gens\",{\"1\":{\"11\":4}}],[\"generic\",{\"1\":{\"5\":1,\"6\":2}}],[\"geman\",{\"1\":{\"3\":2}}],[\"gram\",{\"1\":{\"11\":2}}],[\"graduated\",{\"1\":{\"3\":1}}],[\"group\",{\"1\":{\"7\":4}}],[\"greater\",{\"1\":{\"4\":1}}],[\"guaranteed\",{\"1\":{\"3\":1}}],[\"global\",{\"1\":{\"3\":1,\"16\":2,\"27\":1}}],[\"jit\",{\"1\":{\"30\":3,\"32\":1,\"33\":1}}],[\"jian\",{\"1\":{\"3\":1}}],[\"jvm\",{\"1\":{\"26\":1}}],[\"jacky\",{\"1\":{\"31\":1,\"33\":1}}],[\"java\",{\"1\":{\"25\":1,\"26\":2}}],[\"jann\",{\"1\":{\"3\":1}}],[\"just\",{\"1\":{\"12\":1,\"30\":1}}],[\"j\",{\"1\":{\"11\":3}}],[\"64\",{\"1\":{\"29\":3}}],[\"623429926e\",{\"1\":{\"11\":1}}],[\"6e\",{\"1\":{\"11\":5}}],[\"6\",{\"1\":{\"2\":1,\"11\":16,\"31\":1}}],[\"61\",{\"1\":{\"2\":1}}],[\"404\",{\"1\":{\"34\":1}}],[\"400490086e+04\",{\"1\":{\"11\":1}}],[\"476425e\",{\"1\":{\"11\":1}}],[\"476412e\",{\"1\":{\"11\":1}}],[\"475832e\",{\"1\":{\"11\":1}}],[\"4e+00\",{\"1\":{\"11\":1}}],[\"4e\",{\"1\":{\"11\":9}}],[\"44e\",{\"1\":{\"11\":1}}],[\"448269790e\",{\"1\":{\"11\":1}}],[\"44\",{\"1\":{\"8\":2}}],[\"431945428e+13\",{\"1\":{\"11\":1}}],[\"43\",{\"1\":{\"3\":1}}],[\"4\",{\"1\":{\"2\":1,\"11\":17,\"31\":1}}],[\"416118e\",{\"1\":{\"11\":1}}],[\"412991e\",{\"1\":{\"11\":1}}],[\"414647e\",{\"1\":{\"11\":1}}],[\"41\",{\"1\":{\"2\":1}}],[\"49ms\",{\"1\":{\"1\":1}}],[\"500537e\",{\"1\":{\"11\":1}}],[\"500538e\",{\"1\":{\"11\":1}}],[\"500596e\",{\"1\":{\"11\":1}}],[\"5050\",{\"1\":{\"11\":2}}],[\"5788624960e\",{\"1\":{\"11\":1}}],[\"578862505e\",{\"1\":{\"11\":1}}],[\"578343391e\",{\"1\":{\"11\":1}}],[\"5e+00\",{\"1\":{\"11\":1}}],[\"5e\",{\"1\":{\"11\":4}}],[\"55e\",{\"1\":{\"11\":1}}],[\"55\",{\"1\":{\"11\":2}}],[\"53\",{\"1\":{\"3\":1}}],[\"5\",{\"1\":{\"2\":1,\"11\":15,\"31\":1}}],[\"huls\",{\"1\":{\"33\":1}}],[\"huang\",{\"1\":{\"3\":1}}],[\"h>\",{\"1\":{\"31\":4}}],[\"how\",{\"1\":{\"33\":1}}],[\"however\",{\"1\":{\"4\":2,\"12\":1}}],[\"hostname\",{\"1\":{\"17\":2}}],[\"host\",{\"1\":{\"17\":2}}],[\"hello\",{\"1\":{\"15\":2,\"16\":1}}],[\"header\",{\"1\":{\"8\":1}}],[\"here\",{\"1\":{\"8\":2,\"11\":1,\"15\":1,\"16\":1}}],[\"heuristic\",{\"1\":{\"1\":1}}],[\"h\",{\"1\":{\"6\":8,\"7\":4,\"8\":12}}],[\"high\",{\"1\":{\"4\":2}}],[\"hierarchical\",{\"1\":{\"2\":1}}],[\"hsiang\",{\"1\":{\"4\":1}}],[\"hsinchu\",{\"1\":{\"2\":1}}],[\"handle\",{\"1\":{\"16\":1}}],[\"handling\",{\"1\":{\"15\":1}}],[\"happened\",{\"1\":{\"15\":1}}],[\"have\",{\"1\":{\"4\":1}}],[\"having\",{\"1\":{\"3\":1}}],[\"hardware\",{\"1\":{\"4\":1}}],[\"has\",{\"1\":{\"4\":3,\"8\":6}}],[\"hau\",{\"1\":{\"4\":1}}],[\"utilities\",{\"1\":{\"22\":1}}],[\"utilization\",{\"1\":{\"4\":2}}],[\"utilizing\",{\"1\":{\"1\":1}}],[\"ultimately\",{\"1\":{\"4\":1}}],[\"upper\",{\"1\":{\"11\":4}}],[\"up\",{\"1\":{\"4\":1,\"33\":1}}],[\"upon\",{\"1\":{\"4\":1}}],[\"update\",{\"1\":{\"2\":1}}],[\"us\",{\"1\":{\"10\":1}}],[\"used\",{\"1\":{\"5\":1}}],[\"use\",{\"1\":{\"4\":1,\"5\":3,\"11\":1}}],[\"username=username\",{\"1\":{\"17\":1}}],[\"username\",{\"1\":{\"17\":1}}],[\"users\",{\"1\":{\"4\":2}}],[\"user\",{\"1\":{\"4\":3}}],[\"usage\",{\"1\":{\"4\":3}}],[\"using\",{\"1\":{\"4\":5}}],[\"undef\",{\"1\":{\"31\":2}}],[\"under\",{\"1\":{\"2\":1,\"3\":1,\"11\":1}}],[\"unit\",{\"1\":{\"22\":1}}],[\"unittest\",{\"1\":{\"20\":2,\"22\":1}}],[\"units\",{\"1\":{\"4\":1}}],[\"unknwon\",{\"1\":{\"10\":1}}],[\"urban\",{\"1\":{\"4\":1}}],[\"v\",{\"1\":{\"29\":1,\"30\":4,\"31\":6}}],[\"verbose=true\",{\"1\":{\"11\":1}}],[\"vector\",{\"1\":{\"10\":1}}],[\"vehicle\",{\"1\":{\"4\":1}}],[\"vehicular\",{\"1\":{\"4\":1}}],[\"val`\",{\"1\":{\"15\":1}}],[\"val\",{\"1\":{\"15\":6}}],[\"values\",{\"1\":{\"11\":1}}],[\"value\",{\"1\":{\"8\":13}}],[\"var\",{\"1\":{\"11\":3}}],[\"variables\",{\"1\":{\"11\":10}}],[\"variable\",{\"1\":{\"11\":1}}],[\"various\",{\"1\":{\"4\":3}}],[\"varying\",{\"1\":{\"4\":1}}],[\"void<t>\",{\"1\":{\"6\":3}}],[\"void<void>\",{\"1\":{\"6\":3}}],[\"void<float>\",{\"1\":{\"6\":3}}],[\"void<int>\",{\"1\":{\"6\":3}}],[\"void\",{\"1\":{\"6\":26}}],[\"volume\",{\"1\":{\"4\":1}}],[\"vol\",{\"1\":{\"1\":1}}],[\"viol\",{\"1\":{\"11\":3}}],[\"vibration\",{\"1\":{\"4\":1}}],[\"vision\",{\"1\":{\"3\":1}}],[\"via\",{\"1\":{\"2\":1}}],[\"176319e\",{\"1\":{\"11\":1}}],[\"179446e\",{\"1\":{\"11\":1}}],[\"177790e\",{\"1\":{\"11\":1}}],[\"17\",{\"1\":{\"11\":1}}],[\"171957303e\",{\"1\":{\"11\":1}}],[\"15\",{\"1\":{\"11\":1}}],[\"143887e+00\",{\"1\":{\"11\":2}}],[\"14\",{\"1\":{\"11\":5}}],[\"1477\",{\"1\":{\"1\":1}}],[\"1471\",{\"1\":{\"1\":1}}],[\"16\",{\"1\":{\"11\":2}}],[\"16e+00\",{\"1\":{\"11\":1}}],[\"123\",{\"1\":{\"25\":4}}],[\"1222688931e\",{\"1\":{\"11\":1}}],[\"12\",{\"1\":{\"11\":3}}],[\"12e+00\",{\"1\":{\"11\":1}}],[\"1e+00\",{\"1\":{\"11\":1}}],[\"1e\",{\"1\":{\"11\":2}}],[\"11\",{\"1\":{\"8\":2,\"11\":3}}],[\"19\",{\"1\":{\"3\":1,\"11\":1}}],[\"182936817e\",{\"1\":{\"11\":1}}],[\"18\",{\"1\":{\"3\":1,\"11\":1}}],[\"136\",{\"1\":{\"11\":2}}],[\"135\",{\"1\":{\"11\":1}}],[\"13\",{\"1\":{\"3\":1,\"8\":1,\"11\":2}}],[\"1\",{\"0\":{\"17\":1},\"1\":{\"2\":1,\"5\":1,\"11\":63,\"15\":3,\"16\":2,\"24\":1,\"25\":3,\"27\":2,\"29\":2,\"30\":4,\"31\":3}}],[\"10e+00\",{\"1\":{\"11\":1}}],[\"10000000000000000\",{\"1\":{\"27\":2}}],[\"100\",{\"1\":{\"11\":1}}],[\"10\",{\"1\":{\"4\":1,\"8\":2,\"11\":7}}],[\"10622\",{\"1\":{\"2\":1}}],[\"10616\",{\"1\":{\"2\":1}}],[\"101deg\",{\"1\":{\"1\":1}}],[\"09\",{\"1\":{\"11\":5}}],[\"08\",{\"1\":{\"11\":7}}],[\"07\",{\"1\":{\"11\":9}}],[\"06\",{\"1\":{\"11\":5}}],[\"06e\",{\"1\":{\"11\":1}}],[\"05\",{\"1\":{\"11\":12}}],[\"047962e+00\",{\"1\":{\"11\":6}}],[\"04\",{\"1\":{\"11\":7}}],[\"0e\",{\"1\":{\"11\":5}}],[\"0e+00\",{\"1\":{\"11\":13}}],[\"0343\",{\"1\":{\"22\":1}}],[\"03\",{\"1\":{\"11\":8}}],[\"02e+00\",{\"1\":{\"11\":1}}],[\"02\",{\"1\":{\"11\":19}}],[\"000000e+00\",{\"1\":{\"11\":78}}],[\"0000000000e+00\",{\"1\":{\"11\":1}}],[\"000000000e+00\",{\"1\":{\"11\":19}}],[\"00e\",{\"1\":{\"11\":1}}],[\"00e+00\",{\"1\":{\"11\":3}}],[\"00\",{\"1\":{\"11\":20}}],[\"006m\",{\"1\":{\"1\":1}}],[\"01\",{\"1\":{\"11\":28}}],[\"018m\",{\"1\":{\"1\":1}}],[\"014deg\",{\"1\":{\"1\":1}}],[\"0\",{\"1\":{\"1\":4,\"6\":4,\"7\":4,\"8\":4,\"11\":138,\"15\":2,\"16\":2,\"29\":2,\"30\":4,\"31\":3}}],[\"njit\",{\"1\":{\"30\":2}}],[\"nb\",{\"1\":{\"30\":6}}],[\"ndarray\",{\"1\":{\"28\":2,\"29\":1,\"30\":2}}],[\"nthis\",{\"1\":{\"15\":1,\"16\":1}}],[\"nrm\",{\"1\":{\"11\":3}}],[\"namespace\",{\"1\":{\"31\":1}}],[\"name\",{\"1\":{\"11\":4,\"15\":1,\"16\":1}}],[\"name=\",{\"1\":{\"11\":1}}],[\"navigation\",{\"1\":{\"3\":1,\"4\":4}}],[\"np\",{\"1\":{\"11\":10,\"28\":6,\"29\":3,\"30\":7}}],[\"n\",{\"1\":{\"6\":6,\"7\":2,\"31\":4}}],[\"neon\",{\"1\":{\"31\":2}}],[\"newaxis\",{\"1\":{\"11\":2}}],[\"new\",{\"1\":{\"4\":1,\"15\":2,\"16\":1}}],[\"need\",{\"1\":{\"4\":1,\"11\":1,\"12\":1}}],[\"num\",{\"1\":{\"31\":1}}],[\"numba\",{\"1\":{\"30\":13,\"31\":6,\"32\":1,\"33\":4}}],[\"numpy\",{\"1\":{\"11\":1,\"23\":2,\"28\":3,\"29\":4,\"30\":8,\"31\":8,\"33\":1}}],[\"numerous\",{\"1\":{\"4\":1}}],[\"nuscenes\",{\"1\":{\"1\":1}}],[\"nopython=true\",{\"1\":{\"30\":1}}],[\"norm\",{\"1\":{\"28\":1,\"29\":1,\"30\":1,\"31\":1}}],[\"now\",{\"1\":{\"11\":2}}],[\"not\",{\"1\":{\"8\":5,\"11\":4,\"12\":1,\"15\":3,\"16\":1,\"18\":1,\"34\":1}}],[\"note\",{\"1\":{\"6\":1,\"7\":1,\"12\":1,\"31\":1}}],[\"none\",{\"1\":{\"15\":2,\"18\":1}}],[\"nonzeros\",{\"1\":{\"11\":2}}],[\"non\",{\"1\":{\"3\":2}}],[\"no\",{\"1\":{\"1\":1,\"15\":1}}],[\"slow\",{\"1\":{\"33\":1}}],[\"src\",{\"1\":{\"31\":1}}],[\"sqrt\",{\"1\":{\"30\":1}}],[\"squares\",{\"0\":{\"9\":1,\"10\":1},\"1\":{\"9\":1,\"10\":3,\"11\":2,\"12\":1,\"13\":1}}],[\"square>\",{\"1\":{\"7\":1}}],[\"square\",{\"1\":{\"1\":1,\"7\":5,\"8\":4}}],[\"speed\",{\"1\":{\"33\":1}}],[\"special\",{\"1\":{\"7\":2}}],[\"specialization\",{\"1\":{\"5\":1,\"6\":2}}],[\"specific\",{\"1\":{\"4\":1}}],[\"space\",{\"1\":{\"12\":1}}],[\"smp\",{\"1\":{\"11\":1}}],[\"small\",{\"1\":{\"5\":1}}],[\"smartphone\",{\"1\":{\"4\":1}}],[\"say\",{\"1\":{\"10\":1}}],[\"sam\",{\"1\":{\"2\":1}}],[\"so\",{\"1\":{\"29\":2,\"33\":1}}],[\"socket\",{\"1\":{\"14\":1}}],[\"something\",{\"1\":{\"19\":1}}],[\"some\",{\"1\":{\"12\":1}}],[\"solution\",{\"1\":{\"11\":4}}],[\"solved\",{\"1\":{\"11\":2}}],[\"solve\",{\"1\":{\"4\":1,\"11\":2}}],[\"solver=\",{\"1\":{\"11\":1}}],[\"solver\",{\"1\":{\"3\":3}}],[\"solving\",{\"1\":{\"3\":1}}],[\"sos\",{\"0\":{\"9\":1},\"1\":{\"11\":3}}],[\"sfinae\",{\"1\":{\"8\":1}}],[\"supported\",{\"1\":{\"33\":2}}],[\"suppress\",{\"1\":{\"20\":1}}],[\"surpress\",{\"1\":{\"15\":1}}],[\"subtest\",{\"1\":{\"20\":1}}],[\"subtract\",{\"1\":{\"11\":1}}],[\"substitution\",{\"1\":{\"8\":1}}],[\"substantial\",{\"1\":{\"4\":1}}],[\"summary\",{\"1\":{\"11\":2}}],[\"sum\",{\"0\":{\"9\":1,\"10\":1},\"1\":{\"9\":1,\"10\":3,\"11\":3,\"12\":1,\"13\":1,\"28\":1,\"30\":1}}],[\"such\",{\"1\":{\"4\":1,\"10\":2,\"12\":1,\"15\":1}}],[\"sun\",{\"1\":{\"3\":1}}],[\"single\",{\"1\":{\"30\":2}}],[\"since\",{\"1\":{\"11\":1}}],[\"simply\",{\"1\":{\"12\":1}}],[\"simultaneously\",{\"1\":{\"4\":1}}],[\"simultaneous\",{\"1\":{\"2\":2}}],[\"signals\",{\"1\":{\"4\":1}}],[\"sizeof\",{\"1\":{\"8\":4}}],[\"size\",{\"1\":{\"4\":1}}],[\"s\",{\"1\":{\"3\":1,\"4\":2,\"29\":1,\"30\":4,\"31\":6}}],[\"shared\",{\"1\":{\"29\":2,\"31\":1}}],[\"shape\",{\"1\":{\"11\":2,\"29\":1,\"30\":2}}],[\"shan\",{\"1\":{\"4\":1}}],[\"show\",{\"1\":{\"18\":1}}],[\"shows\",{\"1\":{\"1\":1,\"2\":1,\"3\":1}}],[\"should\",{\"1\":{\"8\":14}}],[\"shien\",{\"1\":{\"3\":1}}],[\"sys\",{\"1\":{\"15\":2,\"18\":3}}],[\"system\",{\"1\":{\"2\":2,\"3\":1,\"4\":1}}],[\"sympy\",{\"1\":{\"11\":4,\"13\":1}}],[\"synthetic\",{\"1\":{\"1\":2}}],[\"second\",{\"1\":{\"15\":2,\"16\":1}}],[\"set\",{\"1\":{\"15\":1,\"28\":1,\"29\":1,\"30\":2,\"31\":2}}],[\"setup\",{\"1\":{\"11\":2}}],[\"semi\",{\"1\":{\"11\":2}}],[\"semidefinite\",{\"0\":{\"11\":1},\"1\":{\"10\":2,\"11\":2,\"12\":1}}],[\"sense\",{\"1\":{\"11\":2}}],[\"sensor\",{\"1\":{\"4\":3}}],[\"sensors\",{\"1\":{\"4\":5}}],[\"services\",{\"1\":{\"4\":1}}],[\"several\",{\"1\":{\"4\":1,\"10\":1}}],[\"sep\",{\"1\":{\"4\":1}}],[\"session\",{\"1\":{\"4\":1}}],[\"selecting\",{\"1\":{\"4\":1}}],[\"selection\",{\"1\":{\"2\":1,\"4\":1}}],[\"self\",{\"1\":{\"2\":1,\"15\":13}}],[\"segmot\",{\"0\":{\"2\":1},\"1\":{\"2\":6}}],[\"study\",{\"0\":{\"17\":1,\"18\":1,\"19\":1}}],[\"stack\",{\"1\":{\"8\":1,\"19\":3}}],[\"standard\",{\"1\":{\"8\":1}}],[\"status\",{\"1\":{\"11\":5}}],[\"statically\",{\"1\":{\"25\":1}}],[\"static\",{\"1\":{\"4\":2,\"6\":10,\"7\":4,\"8\":24}}],[\"statement\",{\"1\":{\"22\":2}}],[\"states\",{\"1\":{\"4\":1}}],[\"state\",{\"1\":{\"1\":1,\"2\":4,\"3\":1,\"4\":2}}],[\"stderr\",{\"1\":{\"18\":1}}],[\"stdout\",{\"0\":{\"18\":1},\"1\":{\"15\":1,\"18\":7}}],[\"std=c++11\",{\"1\":{\"8\":1}}],[\"std\",{\"1\":{\"6\":6,\"7\":2,\"8\":9,\"25\":2}}],[\"string\",{\"1\":{\"25\":2}}],[\"str\",{\"1\":{\"25\":1}}],[\"structure\",{\"1\":{\"8\":1}}],[\"struct\",{\"1\":{\"6\":21,\"7\":4,\"8\":7}}],[\"strategy\",{\"1\":{\"3\":1}}],[\"still\",{\"1\":{\"1\":1}}],[\"science\",{\"1\":{\"33\":1}}],[\"scenes\",{\"1\":{\"4\":1}}],[\"scenarios\",{\"1\":{\"1\":1,\"3\":1,\"4\":6}}],[\"scalarized\",{\"1\":{\"11\":2}}],[\"scalar\",{\"1\":{\"11\":4}}],[\"scale\",{\"1\":{\"1\":1}}],[\"scan\",{\"1\":{\"1\":3}}],[\"o3\",{\"1\":{\"31\":1}}],[\"omp\",{\"1\":{\"30\":3,\"31\":6}}],[\"os\",{\"1\":{\"18\":1}}],[\"openmp\",{\"1\":{\"30\":2,\"31\":2}}],[\"open\",{\"1\":{\"15\":5,\"16\":1,\"17\":1,\"19\":1}}],[\"optimal\",{\"1\":{\"11\":1}}],[\"optimality\",{\"1\":{\"3\":1}}],[\"optimizing\",{\"1\":{\"4\":1}}],[\"optimizer\",{\"1\":{\"11\":14}}],[\"optimize\",{\"1\":{\"4\":1}}],[\"optimization\",{\"0\":{\"38\":1},\"1\":{\"2\":1,\"3\":1,\"11\":2,\"12\":1}}],[\"our\",{\"1\":{\"11\":1}}],[\"outcomes\",{\"1\":{\"3\":1}}],[\"out\",{\"1\":{\"3\":1}}],[\"outlier\",{\"1\":{\"1\":2,\"3\":3}}],[\"overflow\",{\"1\":{\"8\":1}}],[\"overcoming\",{\"1\":{\"4\":1}}],[\"o\",{\"1\":{\"8\":1,\"24\":1}}],[\"oo\",{\"1\":{\"8\":1}}],[\"order\",{\"1\":{\"11\":4}}],[\"orthogonal\",{\"1\":{\"7\":1}}],[\"or\",{\"1\":{\"4\":3,\"5\":2}}],[\"original\",{\"1\":{\"3\":1}}],[\"obviously\",{\"1\":{\"11\":1}}],[\"obj\",{\"1\":{\"11\":3,\"15\":13,\"16\":3}}],[\"objective\",{\"1\":{\"11\":2}}],[\"object\",{\"1\":{\"2\":5,\"5\":2,\"15\":4}}],[\"obtain\",{\"1\":{\"11\":1}}],[\"obtains\",{\"1\":{\"2\":2}}],[\"observation\",{\"1\":{\"4\":3}}],[\"observations\",{\"1\":{\"4\":2}}],[\"odometry\",{\"1\":{\"2\":8}}],[\"only\",{\"1\":{\"10\":1,\"11\":1}}],[\"once\",{\"1\":{\"6\":2,\"7\":2,\"8\":4}}],[\"ones\",{\"1\":{\"4\":1}}],[\"on\",{\"1\":{\"1\":2,\"2\":1,\"4\":3}}],[\"of<g>\",{\"1\":{\"8\":2}}],[\"of<f>\",{\"1\":{\"8\":2}}],[\"of<function\",{\"1\":{\"8\":6}}],[\"of<oo\",{\"1\":{\"8\":1}}],[\"of<exp\",{\"1\":{\"7\":1}}],[\"of<square\",{\"1\":{\"7\":1}}],[\"of\",{\"0\":{\"9\":1,\"10\":2},\"1\":{\"1\":6,\"2\":7,\"3\":4,\"4\":16,\"5\":1,\"7\":15,\"8\":28,\"9\":1,\"10\":5,\"11\":2,\"12\":1,\"13\":1,\"15\":4,\"18\":1,\"28\":3,\"29\":4,\"30\":6}}],[\"bindings\",{\"1\":{\"31\":1}}],[\"bit\",{\"1\":{\"29\":1}}],[\"b\",{\"1\":{\"25\":1,\"27\":1}}],[\"block\",{\"1\":{\"15\":6}}],[\"blog\",{\"1\":{\"8\":1}}],[\"but\",{\"1\":{\"12\":1,\"15\":2,\"16\":1}}],[\"bound\",{\"1\":{\"11\":5}}],[\"bool\",{\"1\":{\"6\":10}}],[\"boosted\",{\"1\":{\"4\":1}}],[\"bendersky\",{\"1\":{\"18\":1}}],[\"before\",{\"1\":{\"4\":1,\"11\":2}}],[\"between\",{\"1\":{\"4\":1}}],[\"better\",{\"1\":{\"3\":2}}],[\"become\",{\"1\":{\"4\":1}}],[\"be\",{\"1\":{\"3\":1,\"4\":2,\"8\":10,\"11\":1,\"15\":5,\"18\":1}}],[\"barvar\",{\"1\":{\"11\":3}}],[\"basis\",{\"1\":{\"10\":1}}],[\"base\",{\"1\":{\"8\":10}}],[\"baseline\",{\"1\":{\"2\":1}}],[\"based\",{\"1\":{\"1\":1,\"2\":1,\"4\":2}}],[\"background\",{\"0\":{\"10\":1}}],[\"bang\",{\"1\":{\"3\":1}}],[\"bytecode\",{\"1\":{\"26\":1}}],[\"by\",{\"0\":{\"11\":1},\"1\":{\"1\":1,\"4\":4,\"5\":1,\"10\":1,\"11\":2,\"12\":1,\"17\":3,\"31\":1,\"33\":1}}],[\"eigen\",{\"1\":{\"31\":8,\"33\":1}}],[\"even\",{\"1\":{\"25\":1}}],[\"eli\",{\"1\":{\"18\":1}}],[\"e\",{\"1\":{\"12\":1,\"31\":1}}],[\"euclidean\",{\"1\":{\"7\":1}}],[\"ezcreflectionfunction\",{\"1\":{\"5\":2}}],[\"ezcreflectionmethod\",{\"1\":{\"5\":2}}],[\"ezcreflectionreturninfo\",{\"1\":{\"5\":3}}],[\"equilibrium\",{\"1\":{\"4\":1}}],[\"equation\",{\"1\":{\"3\":1}}],[\"ekf\",{\"1\":{\"4\":1}}],[\"etc\",{\"1\":{\"4\":1}}],[\"emerged\",{\"1\":{\"4\":1}}],[\"empirical\",{\"1\":{\"1\":1}}],[\"endif\",{\"1\":{\"31\":1}}],[\"enter\",{\"1\":{\"15\":5,\"19\":1}}],[\"energy\",{\"1\":{\"11\":1}}],[\"enum\",{\"1\":{\"8\":2}}],[\"enhance\",{\"1\":{\"4\":1}}],[\"enhanced\",{\"0\":{\"4\":1},\"1\":{\"4\":2}}],[\"enabling\",{\"1\":{\"4\":1}}],[\"environments\",{\"1\":{\"2\":2,\"4\":2}}],[\"essential\",{\"1\":{\"3\":1}}],[\"estimator\",{\"1\":{\"3\":1}}],[\"estimation\",{\"1\":{\"2\":4,\"3\":2}}],[\"ego\",{\"1\":{\"2\":2}}],[\"errors\",{\"1\":{\"2\":1}}],[\"error\",{\"1\":{\"1\":2,\"8\":5}}],[\"exitstack\",{\"0\":{\"19\":1},\"1\":{\"19\":1}}],[\"exit\",{\"1\":{\"15\":7}}],[\"exist\",{\"1\":{\"10\":1}}],[\"existence\",{\"1\":{\"8\":1}}],[\"exception\",{\"1\":{\"15\":6,\"16\":1}}],[\"except\",{\"1\":{\"15\":2,\"16\":1}}],[\"exc\",{\"1\":{\"15\":21}}],[\"excluding\",{\"1\":{\"4\":1}}],[\"example\",{\"1\":{\"11\":2}}],[\"extends\",{\"1\":{\"5\":2}}],[\"extraction\",{\"1\":{\"1\":1}}],[\"export\",{\"1\":{\"29\":1,\"30\":1}}],[\"exponential\",{\"1\":{\"12\":1}}],[\"expounded\",{\"1\":{\"4\":1}}],[\"expected\",{\"1\":{\"8\":10,\"11\":1}}],[\"experiments\",{\"1\":{\"1\":1}}],[\"experiment\",{\"1\":{\"1\":2,\"2\":2}}],[\"exp>\",{\"1\":{\"7\":1}}],[\"exp\",{\"1\":{\"7\":10,\"8\":5}}],[\"exhibits\",{\"1\":{\"3\":1}}],[\"efficiency\",{\"1\":{\"1\":2}}],[\"efficient\",{\"1\":{\"1\":2}}],[\"effectiveness\",{\"1\":{\"1\":2}}],[\"effective\",{\"1\":{\"1\":2,\"4\":1}}],[\"fname\",{\"1\":{\"19\":2}}],[\"flushed\",{\"1\":{\"18\":1}}],[\"flag\",{\"1\":{\"15\":2,\"30\":1}}],[\"flops\",{\"1\":{\"11\":2}}],[\"float64\",{\"1\":{\"29\":3,\"30\":2}}],[\"float\",{\"1\":{\"11\":1,\"28\":2,\"29\":2,\"30\":3}}],[\"f>\",{\"1\":{\"8\":3}}],[\"f\",{\"1\":{\"7\":1,\"8\":12,\"11\":9,\"15\":10,\"16\":4}}],[\"factor\",{\"1\":{\"11\":12}}],[\"failure\",{\"1\":{\"8\":1}}],[\"failed\",{\"1\":{\"8\":4}}],[\"false\",{\"1\":{\"6\":15,\"15\":2}}],[\"faster\",{\"1\":{\"3\":1}}],[\"fast\",{\"1\":{\"3\":2}}],[\"first\",{\"1\":{\"15\":2,\"16\":1}}],[\"firstly\",{\"1\":{\"11\":1}}],[\"find\",{\"1\":{\"12\":1}}],[\"finally\",{\"1\":{\"4\":1,\"11\":1,\"15\":1,\"16\":1}}],[\"files\",{\"1\":{\"19\":1}}],[\"filenames\",{\"1\":{\"19\":2}}],[\"filename\",{\"1\":{\"15\":4,\"16\":2}}],[\"fileresource\",{\"1\":{\"15\":9,\"16\":8}}],[\"file\",{\"1\":{\"8\":1,\"15\":9,\"16\":1,\"18\":1}}],[\"filter\",{\"1\":{\"4\":1}}],[\"filtering\",{\"1\":{\"4\":1}}],[\"funtion\",{\"1\":{\"11\":1}}],[\"functions\",{\"1\":{\"33\":1}}],[\"function\",{\"1\":{\"5\":2,\"6\":1,\"8\":21,\"11\":3,\"12\":1}}],[\"fundamental\",{\"1\":{\"4\":1}}],[\"furnishing\",{\"1\":{\"4\":1}}],[\"furnish\",{\"1\":{\"4\":2}}],[\"fuse\",{\"1\":{\"4\":1}}],[\"feasibile\",{\"1\":{\"11\":1}}],[\"feasibility\",{\"1\":{\"11\":1}}],[\"feasible\",{\"1\":{\"11\":1}}],[\"features\",{\"1\":{\"33\":1}}],[\"feature\",{\"1\":{\"1\":2}}],[\"feedback\",{\"1\":{\"4\":1}}],[\"framework\",{\"1\":{\"22\":1}}],[\"fractional\",{\"1\":{\"3\":3}}],[\"fracgm\",{\"0\":{\"3\":1},\"1\":{\"3\":5}}],[\"fr\",{\"1\":{\"15\":1,\"16\":1}}],[\"free\",{\"1\":{\"15\":1}}],[\"from\",{\"1\":{\"1\":2,\"3\":1,\"8\":3,\"11\":4,\"12\":1}}],[\"found\",{\"1\":{\"34\":1}}],[\"four\",{\"1\":{\"4\":1}}],[\"fopenmp\",{\"1\":{\"30\":2,\"31\":1}}],[\"follow\",{\"1\":{\"11\":1}}],[\"follows\",{\"1\":{\"4\":1}}],[\"following\",{\"1\":{\"1\":1,\"2\":1,\"3\":1,\"4\":1,\"11\":4}}],[\"forced\",{\"1\":{\"11\":1}}],[\"forward\",{\"1\":{\"6\":4}}],[\"format\",{\"1\":{\"11\":1}}],[\"formally\",{\"1\":{\"10\":1}}],[\"form\",{\"1\":{\"11\":1}}],[\"former\",{\"1\":{\"2\":1}}],[\"formulated\",{\"1\":{\"2\":1}}],[\"for\",{\"1\":{\"1\":2,\"2\":3,\"3\":4,\"4\":3,\"8\":1,\"11\":9,\"19\":1,\"22\":1,\"29\":1,\"30\":5,\"31\":2,\"33\":2}}],[\"typing\",{\"1\":{\"15\":1}}],[\"typed\",{\"1\":{\"25\":2}}],[\"typedef\",{\"1\":{\"8\":2}}],[\"type`\",{\"1\":{\"15\":1}}],[\"typename\",{\"1\":{\"7\":1,\"8\":2}}],[\"type\",{\"1\":{\"6\":17,\"8\":3,\"11\":2,\"15\":8,\"25\":2}}],[\"tb`\",{\"1\":{\"15\":1}}],[\"tb\",{\"1\":{\"15\":6}}],[\"txt`\",{\"1\":{\"15\":1}}],[\"txt\",{\"1\":{\"15\":9,\"16\":4,\"19\":3}}],[\"tuple\",{\"1\":{\"11\":1}}],[\"t=void\",{\"1\":{\"6\":1}}],[\"t=float\",{\"1\":{\"6\":1}}],[\"t=int\",{\"1\":{\"6\":1}}],[\"t\",{\"1\":{\"6\":4,\"7\":1,\"8\":5,\"12\":1,\"25\":1}}],[\"triggered\",{\"1\":{\"15\":2}}],[\"try\",{\"1\":{\"15\":1,\"16\":1}}],[\"true\",{\"1\":{\"6\":12,\"15\":2}}],[\"tracebacktype\",{\"1\":{\"15\":1}}],[\"tracking\",{\"1\":{\"2\":5}}],[\"trap\",{\"1\":{\"15\":1}}],[\"trait\",{\"1\":{\"5\":6,\"6\":2,\"7\":2,\"8\":1}}],[\"traits>\",{\"1\":{\"8\":3}}],[\"traits<c>\",{\"1\":{\"8\":2}}],[\"traits<exp>\",{\"1\":{\"7\":1,\"8\":1}}],[\"traits<square>\",{\"1\":{\"7\":1,\"8\":1}}],[\"traits<g>\",{\"1\":{\"7\":2,\"8\":4}}],[\"traits<f>\",{\"1\":{\"7\":1,\"8\":2}}],[\"traits<float>\",{\"1\":{\"6\":3}}],[\"traits<t>\",{\"1\":{\"6\":5}}],[\"traits<int>\",{\"1\":{\"6\":3}}],[\"traits<void>\",{\"1\":{\"6\":5}}],[\"traits\",{\"0\":{\"5\":1},\"1\":{\"5\":2,\"6\":6,\"7\":2,\"8\":7}}],[\"training\",{\"1\":{\"4\":1}}],[\"traditional\",{\"1\":{\"4\":1}}],[\"trajectory\",{\"1\":{\"2\":1}}],[\"translation\",{\"1\":{\"3\":1}}],[\"translational\",{\"1\":{\"2\":1}}],[\"transformation\",{\"1\":{\"1\":1}}],[\"t>\",{\"1\":{\"6\":9,\"7\":2,\"8\":5}}],[\"tile\",{\"1\":{\"11\":2}}],[\"tips\",{\"1\":{\"5\":1,\"6\":2,\"8\":1,\"11\":1,\"15\":1,\"20\":1,\"24\":1,\"27\":1,\"29\":2,\"30\":1,\"31\":1}}],[\"tightly\",{\"1\":{\"4\":1}}],[\"times\",{\"1\":{\"15\":1}}],[\"time\",{\"1\":{\"1\":2,\"3\":1,\"4\":1,\"8\":1,\"11\":12,\"15\":4,\"16\":2,\"18\":1,\"29\":1,\"30\":1}}],[\"tasks\",{\"1\":{\"24\":2}}],[\"target\",{\"1\":{\"11\":1}}],[\"targeted\",{\"1\":{\"2\":1}}],[\"tao\",{\"1\":{\"4\":1}}],[\"terminated\",{\"1\":{\"11\":2}}],[\"terms\",{\"1\":{\"2\":1}}],[\"testing\",{\"1\":{\"11\":1,\"22\":1}}],[\"test<t>\",{\"1\":{\"8\":2}}],[\"test\",{\"1\":{\"8\":4}}],[\"templated\",{\"1\":{\"8\":1}}],[\"template<>\",{\"1\":{\"6\":8,\"7\":2,\"8\":2}}],[\"template<typename\",{\"1\":{\"6\":9,\"7\":3,\"8\":5}}],[\"template\",{\"1\":{\"5\":2,\"6\":7,\"8\":6}}],[\"technology\",{\"1\":{\"4\":1}}],[\"technologies\",{\"1\":{\"4\":1}}],[\"techniques\",{\"1\":{\"3\":1,\"4\":2}}],[\"technique\",{\"1\":{\"3\":1}}],[\"teaser\",{\"1\":{\"1\":2}}],[\"teaser++\",{\"1\":{\"1\":1}}],[\"towards\",{\"1\":{\"33\":1}}],[\"total\",{\"1\":{\"10\":2,\"11\":2,\"12\":1}}],[\"to\",{\"1\":{\"1\":1,\"2\":3,\"3\":6,\"4\":13,\"5\":2,\"8\":1,\"9\":1,\"10\":1,\"11\":2,\"12\":2,\"15\":5,\"31\":1,\"32\":2,\"33\":1}}],[\"thread\",{\"1\":{\"31\":2}}],[\"threads\",{\"1\":{\"11\":2,\"31\":1}}],[\"through\",{\"1\":{\"1\":1,\"4\":2}}],[\"think\",{\"1\":{\"5\":1}}],[\"this\",{\"1\":{\"1\":1,\"3\":2,\"4\":3,\"9\":1,\"10\":1,\"11\":4,\"12\":1,\"15\":3,\"25\":1}}],[\"that\",{\"1\":{\"1\":1,\"2\":3,\"10\":3,\"12\":2}}],[\"then\",{\"1\":{\"11\":1}}],[\"there\",{\"1\":{\"10\":1,\"15\":2}}],[\"them\",{\"1\":{\"3\":1}}],[\"theoretic\",{\"1\":{\"1\":1}}],[\"the\",{\"1\":{\"1\":13,\"2\":11,\"3\":9,\"4\":26,\"8\":5,\"11\":15,\"12\":1,\"15\":10,\"22\":1,\"28\":1,\"29\":1,\"30\":2}}],[\"i\",{\"1\":{\"11\":3,\"15\":2,\"16\":1,\"18\":1,\"24\":1,\"29\":3,\"30\":6,\"31\":4}}],[\"if\",{\"1\":{\"9\":1,\"10\":4,\"11\":2,\"12\":1,\"15\":8,\"16\":3,\"31\":1}}],[\"identifying\",{\"1\":{\"4\":1}}],[\"identification\",{\"1\":{\"4\":2}}],[\"imu\",{\"1\":{\"4\":4}}],[\"import\",{\"1\":{\"11\":6,\"15\":1,\"16\":1,\"17\":2,\"18\":3,\"19\":1,\"27\":1,\"28\":1,\"29\":1,\"30\":3}}],[\"implement\",{\"1\":{\"8\":4}}],[\"implementation\",{\"1\":{\"5\":1}}],[\"impl\",{\"1\":{\"6\":4,\"7\":2,\"8\":2}}],[\"improved\",{\"1\":{\"3\":1,\"4\":1}}],[\"improvement\",{\"1\":{\"2\":2,\"3\":1,\"4\":1}}],[\"impact\",{\"1\":{\"3\":1}}],[\"ion\",{\"1\":{\"4\":1}}],[\"isinstance\",{\"1\":{\"11\":2}}],[\"is\",{\"1\":{\"2\":3,\"3\":1,\"4\":2,\"5\":1,\"6\":32,\"8\":8,\"9\":1,\"10\":6,\"11\":5,\"12\":2,\"15\":4,\"16\":1,\"33\":1}}],[\"issues\",{\"1\":{\"32\":1}}],[\"issue\",{\"1\":{\"1\":1,\"4\":1}}],[\"icra\",{\"1\":{\"2\":1}}],[\"ite\",{\"1\":{\"11\":2}}],[\"items\",{\"1\":{\"11\":1}}],[\"itermonomials\",{\"1\":{\"11\":2}}],[\"iteratively\",{\"1\":{\"3\":1}}],[\"it\",{\"1\":{\"1\":1,\"10\":1,\"11\":1,\"12\":1,\"33\":1}}],[\"itself\",{\"1\":{\"15\":1}}],[\"its\",{\"1\":{\"1\":1}}],[\"init\",{\"1\":{\"15\":1}}],[\"input3\",{\"1\":{\"19\":1}}],[\"input2\",{\"1\":{\"19\":1}}],[\"input1\",{\"1\":{\"19\":1}}],[\"input\",{\"1\":{\"15\":9,\"16\":4}}],[\"index\",{\"1\":{\"11\":2}}],[\"indicators\",{\"1\":{\"4\":1}}],[\"indicates\",{\"1\":{\"2\":1}}],[\"involved\",{\"1\":{\"11\":2}}],[\"info\",{\"1\":{\"15\":1,\"17\":2}}],[\"information\",{\"1\":{\"2\":1,\"4\":1,\"5\":1,\"15\":1}}],[\"infeasible\",{\"1\":{\"11\":4}}],[\"infeasibility\",{\"1\":{\"11\":3}}],[\"included\",{\"1\":{\"8\":1}}],[\"include\",{\"1\":{\"6\":7,\"7\":4,\"8\":5,\"31\":4}}],[\"increased\",{\"1\":{\"4\":1}}],[\"increases\",{\"1\":{\"3\":1}}],[\"increase\",{\"1\":{\"3\":1}}],[\"inheritance\",{\"1\":{\"5\":1}}],[\"into\",{\"1\":{\"15\":1}}],[\"introducing\",{\"1\":{\"9\":1}}],[\"introduction\",{\"1\":{\"4\":1,\"8\":1}}],[\"int\",{\"1\":{\"6\":4,\"7\":1,\"8\":1,\"11\":4,\"25\":2,\"31\":3}}],[\"intellisense\",{\"1\":{\"31\":1}}],[\"intelligence\",{\"1\":{\"4\":1}}],[\"interpreter\",{\"1\":{\"26\":1,\"27\":1,\"30\":1,\"31\":1}}],[\"interpreted\",{\"1\":{\"26\":1}}],[\"interior\",{\"1\":{\"11\":2,\"12\":1}}],[\"international\",{\"1\":{\"2\":1}}],[\"integer\",{\"1\":{\"11\":2}}],[\"integrating\",{\"1\":{\"4\":2}}],[\"integration\",{\"1\":{\"1\":1,\"4\":4}}],[\"integrated\",{\"1\":{\"4\":3}}],[\"inside\",{\"1\":{\"15\":3}}],[\"instantiate\",{\"1\":{\"15\":3,\"16\":1}}],[\"instantiation\",{\"1\":{\"8\":2}}],[\"instability\",{\"1\":{\"2\":1}}],[\"ins\",{\"0\":{\"4\":1},\"1\":{\"4\":1}}],[\"inspired\",{\"1\":{\"1\":1}}],[\"inertial\",{\"1\":{\"2\":2,\"4\":1}}],[\"in\",{\"0\":{\"14\":1},\"1\":{\"1\":3,\"2\":2,\"3\":6,\"4\":7,\"8\":3,\"11\":9,\"15\":3,\"16\":2,\"18\":1,\"19\":1,\"29\":1,\"30\":3}}],[\"ieee\",{\"1\":{\"1\":1,\"3\":1}}],[\"25\",{\"1\":{\"11\":1}}],[\"24\",{\"1\":{\"11\":1}}],[\"24e+00\",{\"1\":{\"11\":1}}],[\"22\",{\"1\":{\"11\":1}}],[\"22e+00\",{\"1\":{\"11\":2}}],[\"26\",{\"1\":{\"11\":1}}],[\"2e\",{\"1\":{\"11\":11}}],[\"23\",{\"1\":{\"4\":1,\"11\":1}}],[\"20\",{\"1\":{\"3\":1,\"11\":1}}],[\"2021\",{\"1\":{\"33\":1}}],[\"2024\",{\"0\":{\"3\":1,\"4\":1},\"1\":{\"3\":1,\"4\":2}}],[\"2023\",{\"0\":{\"2\":1},\"1\":{\"2\":2}}],[\"2022\",{\"0\":{\"1\":1},\"1\":{\"1\":1}}],[\"21\",{\"1\":{\"2\":1,\"11\":3}}],[\"2\",{\"0\":{\"18\":1},\"1\":{\"1\":1,\"5\":1,\"7\":2,\"8\":3,\"11\":29,\"15\":1,\"27\":1,\"30\":2}}],[\"796219e\",{\"1\":{\"11\":3}}],[\"734660260e\",{\"1\":{\"11\":1}}],[\"73e\",{\"1\":{\"11\":2}}],[\"73e+05\",{\"1\":{\"11\":1}}],[\"7e\",{\"1\":{\"11\":3}}],[\"786795893e\",{\"1\":{\"11\":1}}],[\"77ms\",{\"1\":{\"1\":1}}],[\"7\",{\"1\":{\"1\":1,\"11\":10,\"31\":1}}],[\"r\",{\"1\":{\"12\":1,\"15\":8,\"16\":4}}],[\"right\",{\"1\":{\"11\":2}}],[\"run\",{\"1\":{\"12\":1}}],[\"runtime\",{\"1\":{\"8\":1}}],[\"running\",{\"1\":{\"4\":1}}],[\"rule\",{\"1\":{\"7\":1}}],[\"reduction\",{\"1\":{\"30\":2,\"31\":2}}],[\"redirecting\",{\"1\":{\"18\":1}}],[\"redirect\",{\"1\":{\"18\":3}}],[\"resource\",{\"1\":{\"15\":1}}],[\"result\",{\"1\":{\"11\":3}}],[\"results\",{\"1\":{\"2\":1,\"3\":1,\"4\":1}}],[\"release\",{\"1\":{\"15\":1}}],[\"relationship\",{\"1\":{\"4\":1}}],[\"relaxation\",{\"1\":{\"3\":1}}],[\"report\",{\"1\":{\"11\":1}}],[\"representation\",{\"1\":{\"11\":1}}],[\"rewrite\",{\"1\":{\"11\":1}}],[\"required\",{\"1\":{\"8\":2}}],[\"requiring\",{\"1\":{\"4\":1}}],[\"returns\",{\"1\":{\"28\":1,\"29\":1,\"30\":2}}],[\"return\",{\"1\":{\"6\":16,\"7\":6,\"8\":7,\"15\":4,\"28\":1,\"29\":1,\"30\":2,\"31\":2}}],[\"recognition\",{\"1\":{\"4\":1}}],[\"receivers\",{\"1\":{\"4\":1}}],[\"registration\",{\"1\":{\"3\":1}}],[\"rejection\",{\"1\":{\"3\":1}}],[\"ref\",{\"1\":{\"31\":1}}],[\"ref<eigen\",{\"1\":{\"31\":2}}],[\"reflectionfunction\",{\"1\":{\"5\":1}}],[\"reflectionmethod\",{\"1\":{\"5\":1}}],[\"reformulates\",{\"1\":{\"3\":1}}],[\"referrers\",{\"1\":{\"27\":3}}],[\"reference\",{\"1\":{\"27\":1,\"31\":1,\"33\":1}}],[\"references\",{\"0\":{\"13\":1,\"22\":1,\"33\":1}}],[\"refer\",{\"1\":{\"1\":1,\"2\":1,\"3\":1,\"4\":1}}],[\"reveal\",{\"1\":{\"1\":1}}],[\"readers\",{\"1\":{\"30\":1}}],[\"read\",{\"1\":{\"15\":9,\"16\":5}}],[\"reading\",{\"1\":{\"15\":6,\"16\":2}}],[\"reach\",{\"1\":{\"4\":1}}],[\"reaches\",{\"1\":{\"1\":1}}],[\"real\",{\"1\":{\"1\":3,\"3\":1,\"4\":1}}],[\"row\",{\"1\":{\"31\":2}}],[\"rows\",{\"1\":{\"31\":1}}],[\"rowmajor>>\",{\"1\":{\"31\":1}}],[\"rotation\",{\"1\":{\"3\":2,\"7\":1}}],[\"rotational\",{\"1\":{\"2\":1}}],[\"robust\",{\"1\":{\"3\":3}}],[\"robotics\",{\"1\":{\"1\":1,\"2\":1,\"3\":2}}],[\"root\",{\"1\":{\"1\":1}}],[\"raised\",{\"1\":{\"15\":1}}],[\"raise\",{\"1\":{\"15\":1,\"16\":1}}],[\"rapidly\",{\"1\":{\"4\":1}}],[\"range\",{\"1\":{\"4\":1,\"11\":2,\"29\":1,\"30\":1}}],[\"rates\",{\"1\":{\"3\":1}}],[\"rate\",{\"1\":{\"3\":1}}],[\"raw\",{\"1\":{\"2\":1}}],[\"ra\",{\"1\":{\"1\":1,\"3\":1}}],[\"llvm\",{\"1\":{\"31\":1}}],[\"leave\",{\"1\":{\"15\":1}}],[\"learning\",{\"1\":{\"4\":9}}],[\"length\",{\"1\":{\"28\":5,\"29\":7,\"30\":18,\"31\":7}}],[\"len\",{\"1\":{\"11\":1,\"27\":3}}],[\"left\",{\"1\":{\"11\":2}}],[\"leveraging\",{\"1\":{\"3\":1,\"4\":2}}],[\"letters\",{\"1\":{\"1\":1,\"3\":1}}],[\"lock\",{\"1\":{\"27\":1}}],[\"lower\",{\"1\":{\"3\":1,\"11\":4}}],[\"long\",{\"1\":{\"3\":1}}],[\"loam\",{\"1\":{\"1\":1}}],[\"lambda\",{\"1\":{\"11\":1}}],[\"latter\",{\"1\":{\"2\":1}}],[\"laser\",{\"1\":{\"1\":2}}],[\"like\",{\"1\":{\"11\":1}}],[\"list\",{\"1\":{\"11\":2,\"28\":1,\"29\":1,\"30\":2}}],[\"lie\",{\"1\":{\"7\":2}}],[\"lib\",{\"1\":{\"6\":4,\"7\":2,\"8\":7,\"28\":1,\"29\":4,\"30\":3,\"31\":2}}],[\"library\",{\"1\":{\"5\":1,\"8\":1,\"29\":2,\"31\":1}}],[\"limited\",{\"1\":{\"4\":1}}],[\"life\",{\"1\":{\"4\":1}}],[\"li\",{\"1\":{\"4\":1}}],[\"lio\",{\"0\":{\"2\":1},\"1\":{\"2\":8}}],[\"lidar\",{\"1\":{\"1\":1,\"2\":2}}],[\"linux\",{\"1\":{\"29\":1}}],[\"linalg\",{\"1\":{\"28\":1,\"29\":1,\"30\":1}}],[\"line\",{\"1\":{\"15\":2,\"16\":1}}],[\"linear\",{\"1\":{\"3\":1}}],[\"link\",{\"1\":{\"4\":1}}],[\"links\",{\"1\":{\"1\":1,\"2\":1,\"3\":1}}],[\"lin\",{\"1\":{\"1\":2,\"2\":2,\"3\":1,\"4\":3}}],[\"l\",{\"1\":{\"1\":1,\"3\":1}}],[\"dask\",{\"1\":{\"32\":3}}],[\"dataset\",{\"1\":{\"1\":1,\"2\":2,\"4\":1}}],[\"data\",{\"1\":{\"1\":3,\"4\":2,\"33\":1}}],[\"dfeas\",{\"1\":{\"11\":2}}],[\"do\",{\"1\":{\"12\":1,\"18\":1,\"19\":1,\"25\":1}}],[\"dobj\",{\"1\":{\"11\":2}}],[\"does\",{\"1\":{\"11\":1}}],[\"double\",{\"1\":{\"7\":10,\"8\":20,\"15\":1,\"31\":2}}],[\"driving\",{\"1\":{\"4\":1}}],[\"diff\",{\"1\":{\"28\":1}}],[\"differentiable\",{\"1\":{\"7\":1}}],[\"different\",{\"1\":{\"4\":2}}],[\"dim\",{\"1\":{\"11\":2}}],[\"discrete\",{\"1\":{\"28\":1,\"29\":1,\"30\":2}}],[\"distinct\",{\"1\":{\"4\":1}}],[\"disparities\",{\"1\":{\"4\":2}}],[\"diverse\",{\"1\":{\"4\":2}}],[\"duck\",{\"1\":{\"15\":1}}],[\"dual\",{\"1\":{\"3\":1,\"11\":8}}],[\"due\",{\"1\":{\"2\":1,\"4\":1}}],[\"dynamically\",{\"1\":{\"25\":1}}],[\"dynamic\",{\"1\":{\"2\":2,\"31\":3}}],[\"decorator\",{\"1\":{\"30\":1}}],[\"declval<double>\",{\"1\":{\"8\":2}}],[\"decltype\",{\"1\":{\"8\":2}}],[\"declaration\",{\"1\":{\"6\":6}}],[\"descriptor\",{\"1\":{\"18\":1}}],[\"designed\",{\"1\":{\"2\":1}}],[\"dense\",{\"1\":{\"11\":4}}],[\"def\",{\"1\":{\"15\":3,\"16\":1,\"17\":2,\"28\":1,\"29\":1,\"30\":2,\"31\":1}}],[\"definite\",{\"1\":{\"11\":2}}],[\"defaultdict\",{\"1\":{\"11\":4}}],[\"degree\",{\"1\":{\"10\":2,\"11\":9,\"12\":1}}],[\"derivative\",{\"1\":{\"7\":12,\"8\":17}}],[\"derivation\",{\"1\":{\"1\":1}}],[\"delineated\",{\"1\":{\"4\":1}}],[\"demonstrate\",{\"1\":{\"3\":1}}],[\"det\",{\"1\":{\"11\":2}}],[\"determine\",{\"1\":{\"5\":1,\"15\":1}}],[\"determining\",{\"1\":{\"4\":1}}],[\"detection\",{\"1\":{\"4\":1}}],[\"detections\",{\"1\":{\"2\":1}}],[\"details\",{\"1\":{\"1\":1,\"3\":1,\"5\":1}}],[\"d\",{\"1\":{\"1\":1,\"3\":1}}],[\"37m\",{\"1\":{\"29\":1}}],[\"374090e\",{\"1\":{\"11\":3}}],[\"36e+03\",{\"1\":{\"11\":1}}],[\"3e\",{\"1\":{\"11\":10}}],[\"30\",{\"1\":{\"4\":1}}],[\"3\",{\"0\":{\"19\":1},\"1\":{\"1\":1,\"3\":1,\"8\":5,\"11\":13,\"27\":1,\"30\":1}}],[\"piecewice\",{\"1\":{\"28\":2,\"30\":2}}],[\"pybind11\",{\"1\":{\"31\":12,\"32\":1,\"33\":1}}],[\"pythran\",{\"1\":{\"29\":7,\"30\":11,\"31\":7,\"32\":1,\"33\":1}}],[\"python\",{\"0\":{\"11\":1,\"14\":1,\"23\":1,\"24\":1,\"26\":1,\"27\":1,\"39\":1},\"1\":{\"14\":1,\"15\":7,\"16\":1,\"18\":2,\"20\":1,\"21\":3,\"23\":3,\"24\":3,\"26\":4,\"27\":4,\"28\":2,\"29\":3,\"30\":2,\"31\":12,\"32\":3,\"33\":1}}],[\"py\",{\"1\":{\"28\":1,\"29\":2,\"30\":3,\"31\":1}}],[\"pfeas\",{\"1\":{\"11\":2}}],[\"psd=true\",{\"1\":{\"11\":1}}],[\"public\",{\"1\":{\"6\":1,\"8\":4}}],[\"purpose\",{\"1\":{\"5\":1}}],[\"php\",{\"1\":{\"5\":3}}],[\"phones\",{\"1\":{\"4\":1}}],[\"phone\",{\"1\":{\"4\":3}}],[\"platform\",{\"1\":{\"4\":1}}],[\"please\",{\"1\":{\"1\":1,\"2\":1,\"3\":1,\"4\":1}}],[\"pass\",{\"1\":{\"31\":1,\"33\":1}}],[\"pandas\",{\"1\":{\"31\":1}}],[\"parallelization\",{\"1\":{\"33\":1}}],[\"parallel=true\",{\"1\":{\"30\":1}}],[\"parallel\",{\"1\":{\"30\":4,\"31\":2}}],[\"parameters\",{\"1\":{\"4\":3}}],[\"partial\",{\"1\":{\"5\":1,\"6\":2}}],[\"paper\",{\"1\":{\"4\":3}}],[\"pattern\",{\"1\":{\"3\":1}}],[\"pep\",{\"1\":{\"22\":1}}],[\"permission\",{\"1\":{\"15\":1}}],[\"performing\",{\"1\":{\"10\":1,\"12\":1}}],[\"performance\",{\"1\":{\"4\":1}}],[\"pedestrian\",{\"1\":{\"4\":2}}],[\"pei\",{\"1\":{\"4\":1}}],[\"penetration\",{\"1\":{\"1\":1}}],[\"pobj\",{\"1\":{\"11\":2}}],[\"polys\",{\"1\":{\"11\":1}}],[\"poly\",{\"1\":{\"11\":11}}],[\"polynomial\",{\"1\":{\"9\":1,\"10\":3,\"11\":5,\"12\":1}}],[\"polynomials\",{\"0\":{\"9\":1,\"10\":1},\"1\":{\"10\":1,\"12\":1}}],[\"policy\",{\"1\":{\"5\":1}}],[\"potential\",{\"1\":{\"4\":1}}],[\"positive\",{\"1\":{\"10\":1,\"11\":1}}],[\"positioning\",{\"1\":{\"4\":6}}],[\"posts\",{\"0\":{\"37\":1}}],[\"post\",{\"1\":{\"3\":1,\"9\":1,\"12\":1}}],[\"poor\",{\"1\":{\"2\":1}}],[\"point\",{\"1\":{\"1\":2,\"3\":1,\"11\":2,\"12\":1}}],[\"points\",{\"1\":{\"1\":3,\"28\":5,\"29\":7,\"30\":14}}],[\"prange\",{\"1\":{\"30\":2}}],[\"pragma\",{\"1\":{\"6\":2,\"7\":2,\"8\":4,\"31\":2}}],[\"prstatus\",{\"1\":{\"11\":2}}],[\"primal\",{\"1\":{\"11\":10}}],[\"primary\",{\"1\":{\"4\":1}}],[\"print\",{\"1\":{\"6\":15,\"15\":8,\"16\":4,\"18\":2}}],[\"private\",{\"1\":{\"6\":1}}],[\"precise\",{\"1\":{\"4\":1}}],[\"predict\",{\"1\":{\"4\":1}}],[\"pre\",{\"1\":{\"3\":1}}],[\"presents\",{\"1\":{\"4\":2}}],[\"present\",{\"1\":{\"3\":1,\"4\":1}}],[\"preserving\",{\"1\":{\"2\":1}}],[\"preventing\",{\"1\":{\"2\":1}}],[\"projects\",{\"0\":{\"35\":1}}],[\"projection\",{\"1\":{\"3\":1}}],[\"process\",{\"1\":{\"15\":3}}],[\"processing\",{\"1\":{\"3\":2}}],[\"procedure\",{\"1\":{\"11\":1}}],[\"program\",{\"1\":{\"11\":1}}],[\"programming\",{\"0\":{\"11\":1},\"1\":{\"3\":2,\"5\":1,\"9\":1,\"10\":1,\"11\":1,\"12\":1,\"13\":1}}],[\"products\",{\"1\":{\"4\":2}}],[\"problems\",{\"1\":{\"4\":1,\"30\":1}}],[\"problem\",{\"1\":{\"3\":3,\"11\":14}}],[\"property\",{\"1\":{\"10\":1}}],[\"properly\",{\"1\":{\"2\":1}}],[\"proposed\",{\"1\":{\"3\":2,\"4\":1}}],[\"propose\",{\"1\":{\"1\":1,\"2\":1}}],[\"provider\",{\"1\":{\"4\":1}}],[\"provide\",{\"1\":{\"2\":1,\"4\":2}}],[\"pruning\",{\"1\":{\"1\":3}}],[\"pp\",{\"1\":{\"1\":1,\"2\":1}}],[\"mike\",{\"1\":{\"33\":1}}],[\"min\",{\"1\":{\"4\":1,\"11\":2}}],[\"minimize\",{\"1\":{\"3\":1,\"4\":1,\"11\":1}}],[\"m\",{\"1\":{\"31\":2}}],[\"mu\",{\"1\":{\"11\":2}}],[\"multiple\",{\"1\":{\"2\":2,\"4\":1}}],[\"multi\",{\"1\":{\"1\":1}}],[\"ml\",{\"1\":{\"4\":1,\"11\":2}}],[\"mcclure\",{\"1\":{\"3\":2}}],[\"modules\",{\"1\":{\"33\":1}}],[\"module\",{\"1\":{\"31\":1}}],[\"mode\",{\"1\":{\"15\":6,\"16\":4}}],[\"modern\",{\"1\":{\"4\":1}}],[\"model\",{\"1\":{\"2\":1}}],[\"mosek\",{\"1\":{\"11\":2}}],[\"monolist\",{\"1\":{\"11\":3}}],[\"monoms\",{\"1\":{\"11\":3}}],[\"monom\",{\"1\":{\"11\":11}}],[\"monomials\",{\"1\":{\"11\":1}}],[\"monomial\",{\"1\":{\"10\":1}}],[\"mobile\",{\"1\":{\"4\":5}}],[\"motion\",{\"1\":{\"2\":2}}],[\"more\",{\"1\":{\"1\":1,\"2\":1,\"3\":1,\"4\":2}}],[\"management\",{\"0\":{\"14\":1}}],[\"manually\",{\"1\":{\"12\":1}}],[\"manifold\",{\"1\":{\"7\":1}}],[\"map\",{\"1\":{\"11\":1}}],[\"max\",{\"1\":{\"11\":3}}],[\"maximum\",{\"1\":{\"1\":3,\"10\":2}}],[\"matrix<\",{\"1\":{\"31\":1}}],[\"matrix<double\",{\"1\":{\"31\":1}}],[\"matrix\",{\"1\":{\"10\":1,\"11\":5,\"12\":1}}],[\"matching\",{\"1\":{\"1\":5}}],[\"main\",{\"1\":{\"5\":1,\"6\":4,\"7\":1,\"15\":1,\"16\":1}}],[\"machine\",{\"1\":{\"4\":9,\"26\":1}}],[\"may\",{\"1\":{\"1\":1,\"2\":1}}],[\"medium\",{\"1\":{\"33\":1}}],[\"mediatek\",{\"1\":{\"4\":3}}],[\"member\",{\"1\":{\"8\":5}}],[\"mentioned\",{\"1\":{\"4\":1}}],[\"measurements\",{\"1\":{\"3\":1}}],[\"means\",{\"1\":{\"12\":1}}],[\"meanwhile\",{\"1\":{\"2\":1}}],[\"mean\",{\"1\":{\"1\":1}}],[\"mechanism\",{\"1\":{\"2\":1}}],[\"method\",{\"1\":{\"1\":1,\"4\":2,\"12\":1}}],[\"me\",{\"0\":{\"0\":1}}],[\"aot\",{\"1\":{\"29\":1}}],[\"ahead\",{\"1\":{\"29\":1}}],[\"axis=0\",{\"1\":{\"28\":1}}],[\"axis=1\",{\"1\":{\"11\":1,\"28\":1}}],[\"avoid\",{\"1\":{\"15\":1}}],[\"average\",{\"1\":{\"1\":3,\"2\":2,\"4\":1}}],[\"am\",{\"1\":{\"15\":2,\"16\":1}}],[\"among\",{\"1\":{\"4\":1}}],[\"at\",{\"1\":{\"7\":4,\"9\":1,\"18\":1}}],[\"after\",{\"1\":{\"4\":1,\"11\":2}}],[\"automatic\",{\"1\":{\"33\":1}}],[\"automatically\",{\"1\":{\"4\":1}}],[\"automation\",{\"1\":{\"1\":1,\"2\":1,\"3\":1}}],[\"adjusting\",{\"1\":{\"4\":2}}],[\"addition\",{\"1\":{\"3\":1}}],[\"ago\",{\"1\":{\"4\":1}}],[\"against\",{\"1\":{\"1\":1,\"2\":1}}],[\"arm\",{\"1\":{\"31\":2}}],[\"args\",{\"1\":{\"28\":1,\"29\":1,\"30\":2}}],[\"arc\",{\"1\":{\"28\":3,\"29\":4,\"30\":7,\"31\":3}}],[\"array\",{\"1\":{\"11\":2}}],[\"are\",{\"1\":{\"4\":1,\"11\":2,\"12\":1}}],[\"areas\",{\"1\":{\"4\":1}}],[\"artificial\",{\"1\":{\"4\":1}}],[\"art\",{\"1\":{\"1\":1,\"2\":1,\"3\":1}}],[\"aims\",{\"1\":{\"9\":1}}],[\"aiming\",{\"1\":{\"3\":1}}],[\"ai\",{\"0\":{\"4\":1},\"1\":{\"4\":2}}],[\"all\",{\"1\":{\"18\":1}}],[\"allows\",{\"1\":{\"10\":1}}],[\"algebraic\",{\"1\":{\"11\":1}}],[\"algebra\",{\"1\":{\"7\":1}}],[\"algorithms\",{\"1\":{\"3\":1,\"4\":1}}],[\"algorithm\",{\"1\":{\"3\":1,\"5\":1,\"12\":1}}],[\"along\",{\"1\":{\"3\":1}}],[\"alternating\",{\"1\":{\"3\":1}}],[\"also\",{\"1\":{\"1\":1,\"2\":1}}],[\"able\",{\"1\":{\"12\":1}}],[\"abc\",{\"1\":{\"11\":1}}],[\"abnormal\",{\"1\":{\"4\":1}}],[\"above\",{\"1\":{\"4\":1,\"11\":1}}],[\"about\",{\"0\":{\"0\":1}}],[\"absolute\",{\"1\":{\"2\":1}}],[\"actually\",{\"1\":{\"15\":2,\"16\":1}}],[\"access\",{\"1\":{\"15\":1}}],[\"accu\",{\"1\":{\"8\":1}}],[\"accurate\",{\"1\":{\"4\":1}}],[\"accuracy\",{\"1\":{\"2\":2,\"3\":1,\"4\":7}}],[\"achieve\",{\"1\":{\"4\":1}}],[\"achieves\",{\"1\":{\"1\":1,\"3\":1}}],[\"achieving\",{\"1\":{\"4\":1}}],[\"across\",{\"1\":{\"4\":3}}],[\"asyncssh\",{\"1\":{\"17\":2}}],[\"asynchronous\",{\"1\":{\"2\":2}}],[\"assertraises\",{\"1\":{\"20\":1}}],[\"assertion\",{\"1\":{\"8\":4}}],[\"assert\",{\"1\":{\"8\":13}}],[\"aspect\",{\"1\":{\"4\":1}}],[\"as\",{\"1\":{\"2\":1,\"4\":4,\"5\":1,\"11\":6,\"15\":6,\"16\":3,\"17\":1,\"19\":1,\"28\":1,\"29\":1,\"30\":3}}],[\"a\",{\"1\":{\"1\":3,\"2\":3,\"3\":6,\"4\":9,\"5\":2,\"8\":11,\"9\":2,\"10\":5,\"11\":2,\"12\":3,\"15\":5,\"16\":2,\"25\":8,\"27\":7,\"28\":2,\"29\":2,\"30\":4}}],[\"api\",{\"1\":{\"31\":4}}],[\"append\",{\"1\":{\"11\":1}}],[\"applying\",{\"1\":{\"4\":1}}],[\"appropriate\",{\"1\":{\"4\":1}}],[\"approaches\",{\"1\":{\"1\":1,\"3\":1}}],[\"approach\",{\"1\":{\"1\":3,\"2\":3}}],[\"apr\",{\"1\":{\"1\":1}}],[\"anything\",{\"1\":{\"18\":1}}],[\"any\",{\"1\":{\"11\":1,\"18\":1}}],[\"another\",{\"1\":{\"5\":1,\"11\":1}}],[\"an\",{\"1\":{\"1\":2,\"2\":3,\"3\":1,\"4\":1,\"8\":2,\"10\":1,\"15\":1}}],[\"and\",{\"1\":{\"1\":10,\"2\":9,\"3\":8,\"4\":11,\"10\":1,\"11\":7,\"15\":4,\"33\":2}}],[\"cython\",{\"1\":{\"29\":2,\"32\":2}}],[\"cer\",{\"1\":{\"11\":1}}],[\"ceil\",{\"1\":{\"11\":1}}],[\"cpython\",{\"1\":{\"29\":2,\"31\":4}}],[\"cpu\",{\"1\":{\"24\":1,\"26\":1,\"30\":1}}],[\"cp\",{\"1\":{\"11\":4}}],[\"cppreference\",{\"1\":{\"8\":1}}],[\"cpp\",{\"0\":{\"36\":1},\"1\":{\"6\":2,\"7\":1,\"8\":4,\"31\":1}}],[\"cvxpy\",{\"0\":{\"9\":1},\"1\":{\"11\":2,\"13\":1}}],[\"c>\",{\"1\":{\"8\":4}}],[\"c\",{\"1\":{\"6\":1,\"27\":1,\"29\":1,\"32\":1}}],[\"c++11\",{\"1\":{\"8\":1}}],[\"c++\",{\"0\":{\"5\":1},\"1\":{\"5\":4,\"6\":6,\"8\":3,\"25\":1,\"29\":1,\"31\":8,\"32\":5}}],[\"cupy\",{\"1\":{\"32\":1}}],[\"cuda\",{\"1\":{\"30\":1,\"33\":1}}],[\"curve\",{\"1\":{\"28\":1,\"29\":1,\"30\":2}}],[\"curvature\",{\"1\":{\"1\":1}}],[\"customer\",{\"1\":{\"4\":1}}],[\"critical\",{\"1\":{\"4\":1}}],[\"criterion\",{\"1\":{\"2\":1}}],[\"c4\",{\"1\":{\"4\":1}}],[\"case\",{\"0\":{\"17\":1,\"18\":1,\"19\":1},\"1\":{\"11\":1}}],[\"calculation\",{\"1\":{\"11\":1}}],[\"calibration\",{\"1\":{\"4\":2}}],[\"carry\",{\"1\":{\"5\":1}}],[\"carrier\",{\"1\":{\"4\":1}}],[\"capacity\",{\"1\":{\"4\":1}}],[\"capability\",{\"1\":{\"3\":1}}],[\"can\",{\"1\":{\"2\":1,\"3\":1,\"4\":5,\"11\":1,\"16\":1,\"25\":1}}],[\"char\",{\"1\":{\"8\":4}}],[\"chain\",{\"1\":{\"7\":1}}],[\"challenges\",{\"1\":{\"4\":2}}],[\"challenging\",{\"1\":{\"4\":3}}],[\"chan\",{\"1\":{\"4\":1}}],[\"checking\",{\"0\":{\"9\":1}}],[\"check\",{\"1\":{\"8\":1,\"9\":1,\"10\":1,\"11\":1,\"12\":1}}],[\"cherng\",{\"1\":{\"3\":1}}],[\"chern\",{\"1\":{\"3\":1}}],[\"chen\",{\"1\":{\"3\":2}}],[\"ching\",{\"1\":{\"3\":1}}],[\"chih\",{\"1\":{\"1\":1,\"2\":1,\"3\":1}}],[\"chieh\",{\"1\":{\"1\":2,\"2\":2}}],[\"code\",{\"1\":{\"26\":1}}],[\"copy\",{\"1\":{\"11\":1}}],[\"corresponding\",{\"1\":{\"11\":2,\"12\":1}}],[\"correspondences\",{\"1\":{\"1\":1}}],[\"correspondence\",{\"1\":{\"1\":1}}],[\"coeffs\",{\"1\":{\"11\":1}}],[\"coeff\",{\"1\":{\"11\":8}}],[\"collect\",{\"1\":{\"15\":1}}],[\"collections\",{\"1\":{\"11\":1}}],[\"collected\",{\"1\":{\"2\":1,\"4\":1}}],[\"counter\",{\"1\":{\"15\":1}}],[\"count\",{\"1\":{\"15\":6,\"16\":8,\"31\":2}}],[\"counting\",{\"1\":{\"15\":1,\"27\":1}}],[\"cout\",{\"1\":{\"6\":6,\"7\":2}}],[\"coupled\",{\"1\":{\"4\":1}}],[\"couple\",{\"1\":{\"2\":1}}],[\"costs\",{\"1\":{\"4\":1}}],[\"conn\",{\"1\":{\"17\":2}}],[\"connect\",{\"1\":{\"17\":2}}],[\"config\",{\"1\":{\"17\":6}}],[\"conference\",{\"1\":{\"2\":1}}],[\"conclusion\",{\"0\":{\"12\":1}}],[\"cone\",{\"1\":{\"11\":1}}],[\"cones\",{\"1\":{\"11\":4}}],[\"con\",{\"1\":{\"11\":3}}],[\"conic\",{\"1\":{\"11\":6}}],[\"consider\",{\"1\":{\"11\":1}}],[\"consistent\",{\"1\":{\"4\":1}}],[\"constraint\",{\"1\":{\"11\":3}}],[\"constraints=constraints\",{\"1\":{\"11\":1}}],[\"constraints\",{\"1\":{\"11\":9}}],[\"constructed\",{\"1\":{\"11\":1}}],[\"construct\",{\"1\":{\"11\":2}}],[\"conducting\",{\"1\":{\"4\":1}}],[\"conditions\",{\"1\":{\"3\":1}}],[\"convergence\",{\"1\":{\"3\":1}}],[\"convexity\",{\"1\":{\"3\":1}}],[\"convex\",{\"1\":{\"3\":2}}],[\"content\",{\"1\":{\"15\":1}}],[\"contexts\",{\"1\":{\"22\":1}}],[\"contextmanger\",{\"1\":{\"17\":1}}],[\"contextmanager\",{\"1\":{\"16\":1}}],[\"contextlib\",{\"0\":{\"16\":1},\"1\":{\"14\":1,\"16\":5,\"17\":2,\"18\":3,\"19\":3,\"20\":1,\"22\":1}}],[\"context\",{\"0\":{\"14\":1},\"1\":{\"19\":1}}],[\"contributions\",{\"1\":{\"4\":1}}],[\"contrast\",{\"1\":{\"4\":1}}],[\"continuous\",{\"1\":{\"2\":1}}],[\"contain\",{\"1\":{\"1\":1}}],[\"com\",{\"1\":{\"8\":1}}],[\"compilation\",{\"1\":{\"29\":1,\"30\":1}}],[\"compiled\",{\"1\":{\"26\":1}}],[\"compile\",{\"1\":{\"8\":1}}],[\"complexity\",{\"1\":{\"12\":1}}],[\"comprehensive\",{\"1\":{\"4\":1}}],[\"compute\",{\"1\":{\"28\":1,\"29\":1,\"30\":2}}],[\"computer\",{\"1\":{\"3\":1}}],[\"computing\",{\"1\":{\"4\":1}}],[\"computation\",{\"1\":{\"3\":1}}],[\"computational\",{\"1\":{\"1\":2}}],[\"compared\",{\"1\":{\"3\":2}}],[\"compare\",{\"1\":{\"1\":1,\"2\":1}}],[\"comes\",{\"1\":{\"1\":2}}],[\"class\",{\"1\":{\"5\":3,\"6\":2,\"7\":2,\"8\":6,\"15\":1}}],[\"classifying\",{\"1\":{\"4\":1}}],[\"close\",{\"1\":{\"15\":2,\"16\":1}}],[\"closest\",{\"1\":{\"1\":3}}],[\"cloud\",{\"1\":{\"3\":1}}],[\"clique\",{\"1\":{\"1\":3}}],[\"writers\",{\"1\":{\"30\":1}}],[\"write\",{\"1\":{\"15\":4,\"16\":5}}],[\"writing\",{\"1\":{\"15\":1}}],[\"w\",{\"1\":{\"12\":1,\"15\":2,\"16\":2}}],[\"would\",{\"1\":{\"11\":1,\"15\":3,\"18\":1}}],[\"worldwide\",{\"1\":{\"4\":1}}],[\"world\",{\"1\":{\"1\":3,\"3\":1,\"15\":2,\"16\":1}}],[\"will\",{\"1\":{\"4\":2,\"15\":2}}],[\"wide\",{\"1\":{\"4\":1}}],[\"within\",{\"1\":{\"4\":1}}],[\"with\",{\"0\":{\"9\":1},\"1\":{\"1\":2,\"2\":1,\"3\":2,\"4\":7,\"8\":2,\"10\":1,\"14\":1,\"15\":14,\"16\":3,\"17\":1,\"18\":2,\"19\":1,\"21\":1,\"22\":2,\"28\":1,\"29\":1,\"30\":2,\"31\":1,\"33\":1}}],[\"why\",{\"1\":{\"33\":1}}],[\"which\",{\"1\":{\"11\":2}}],[\"while\",{\"1\":{\"2\":1,\"3\":1,\"4\":1}}],[\"whose\",{\"1\":{\"5\":1}}],[\"where\",{\"1\":{\"10\":1}}],[\"whether\",{\"1\":{\"4\":1}}],[\"when\",{\"1\":{\"3\":1,\"15\":3}}],[\"warning\",{\"1\":{\"18\":1,\"30\":2}}],[\"want\",{\"1\":{\"15\":1}}],[\"wang\",{\"1\":{\"1\":1,\"2\":1}}],[\"way\",{\"1\":{\"9\":1,\"15\":1}}],[\"walking\",{\"1\":{\"4\":1}}],[\"wahba\",{\"1\":{\"3\":1}}],[\"wei\",{\"1\":{\"3\":1}}],[\"well\",{\"1\":{\"1\":1,\"10\":1}}],[\"we\",{\"1\":{\"1\":3,\"2\":2,\"3\":2,\"10\":1,\"11\":9,\"12\":3}}],[\"wen\",{\"1\":{\"1\":1,\"2\":1}}],[\"kinds\",{\"1\":{\"18\":1}}],[\"kitti\",{\"1\":{\"2\":1}}],[\"knowledge\",{\"0\":{\"10\":1}}],[\"known\",{\"1\":{\"1\":1,\"10\":1}}],[\"key\",{\"1\":{\"4\":1}}],[\"keyframe\",{\"1\":{\"2\":1}}],[\"kalman\",{\"1\":{\"4\":1}}],[\"kao\",{\"1\":{\"4\":1}}],[\"kai\",{\"1\":{\"1\":1,\"2\":1,\"3\":1,\"4\":1}}],[\"k\",{\"1\":{\"1\":3}}],[\"kcp\",{\"0\":{\"1\":1},\"1\":{\"1\":6}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
